{
  "language": "Solidity",
  "sources": {
    "contracts/ABridgeRouter.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// ============ Internal Imports ============\nimport {BridgeMessage} from \"./BridgeMessage.sol\";\nimport {ABridgeToken} from \"./ABridgeToken.sol\";\nimport {TokenRegistry} from \"./TokenRegistry.sol\";\n\n// ============ External Imports ============\nimport {XAppConnectionClient} from \"./nomad/router/XAppConnectionClient.sol\";\nimport {Router} from \"./nomad/router/Router.sol\";\nimport {Home} from \"./nomad/core/Home.sol\";\nimport {TypeCasts} from \"./nomad/core/libs/TypeCasts.sol\";\nimport {TypedMemView} from \"./summa/TypedMemView.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract ABridgeRouter is Router {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using BridgeMessage for bytes29;\n    using SafeERC20 for IERC20;\n\n    // ============ Public Storage ============\n\n    // contract that manages registry representation tokens\n    TokenRegistry public tokenRegistry;\n\n    // mapping tracking the amount of shares for a canonical aToken locked up to a destination.\n    // Used to calculate the current supply for representation tokens\n    mapping(bytes32 => uint256) private canonicalSharesAtDestination;\n\n    // ======== Events =========\n\n    /**\n     * @notice emitted when tokens are sent from this domain to another domain\n     * @param token the address of the token contract\n     * @param from the address sending tokens\n     * @param toDomain the domain of the chain the tokens are being sent to\n     * @param toId the bytes32 address of the recipient of the tokens\n     * @param amount the amount of tokens sent\n     */\n    event Send(\n        address indexed token,\n        address indexed from,\n        uint32 indexed toDomain,\n        bytes32 toId,\n        uint256 amount\n    );\n\n    /**\n     * @notice emitted when tokens are dispensed to an account on this domain\n     * emitted when the transfer ultimately settles\n     * @param originAndNonce Domain where the transfer originated and the unique identifier\n     * for the message from origin to destination, combined in a single field ((origin << 32) & nonce)\n     * @param token The address of the local token contract being received\n     * @param recipient The address receiving the tokens; the original recipient of the transfer\n     * @param amount The amount of tokens being received\n     */\n    event Receive(\n        uint64 indexed originAndNonce,\n        address indexed token,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    // ======== Receive =======\n    receive() external payable {}\n\n    // ======== Initializer ========\n\n    function initialize(address _tokenRegistry, address _xAppConnectionManager)\n        public\n        initializer\n    {\n        tokenRegistry = TokenRegistry(_tokenRegistry);\n        __XAppConnectionClient_initialize(_xAppConnectionManager);\n    }\n\n    // ======== External =========\n\n    // ===== Handle ======\n\n    /**\n     * @notice Handles an incoming message\n     * @param _origin The origin domain\n     * @param _nonce The unique identifier for the message from origin to destination\n     * @param _sender The sender address\n     * @param _message The message\n     */\n    function handle(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes32 _sender,\n        bytes memory _message\n    ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n        // parse tokenId and action from message\n        bytes29 _msg = _message.ref(0).mustBeMessage();\n        bytes29 _tokenId = _msg.tokenId();\n        bytes29 _action = _msg.action();\n        // handle message based on the intended action\n        if (_action.isTransfer()) {\n            _handleTransfer(_origin, _nonce, _tokenId, _action);\n        } else if (_action.isUpdateSupply()) {\n            _handleUpdateSupply(_tokenId, _action);\n        } else {\n            require(false, \"!valid action\");\n        }\n    }\n\n    // ===== Send ======\n\n    /**\n     * @notice Send tokens to a recipient on a remote chain\n     * @param _token The token address\n     * @param _amount The token amount\n     * @param _destination The destination domain\n     * @param _recipient The recipient address\n     */\n    function send(\n        address _token,\n        uint256 _amount,\n        uint32 _destination,\n        bytes32 _recipient\n    ) external {\n        // validate inputs\n        require(_recipient != bytes32(0), \"!recip\");\n        // debit tokens from the sender\n        (bytes29 _tokenId, bytes32 _detailsHash) = _takeTokens(_token, _amount);\n        // format Transfer message\n        bytes29 _action = BridgeMessage.formatTransfer(\n            _recipient,\n            _amount,\n            _detailsHash\n        );\n        // send message to destination chain bridge router\n        _sendTransferMessage(_destination, _tokenId, _action);\n        // emit Send event to record token sender\n        emit Send(_token, msg.sender, _destination, _recipient, _amount);\n    }\n\n    // ===== SendToHook ======\n\n    /**\n     * @notice Send tokens to a hook on the remote chain\n     * @param _token The token address\n     * @param _amount The token amount\n     * @param _destination The destination domain\n     * @param _remoteHook The hook contract on the remote chain\n     * @param _extraData Extra data that will be passed to the hook for\n     *        execution\n     */\n    function sendToHook(\n        address _token,\n        uint256 _amount,\n        uint32 _destination,\n        bytes32 _remoteHook,\n        bytes calldata _extraData\n    ) external {\n        // debit tokens from msg.sender\n        (bytes29 _tokenId, bytes32 _detailsHash) = _takeTokens(_token, _amount);\n        // format Hook transfer message\n        bytes29 _action = BridgeMessage.formatTransferToHook(\n            _remoteHook,\n            _amount,\n            _detailsHash,\n            TypeCasts.addressToBytes32(msg.sender),\n            _extraData\n        );\n        // send message to destination chain bridge router\n        _sendTransferMessage(_destination, _tokenId, _action);\n        // emit Send event to record token sender\n        emit Send(_token, msg.sender, _destination, _remoteHook, _amount);\n    }\n\n    // ======== Internal Handlers =========\n\n    // ===== handleTransfer ======\n    function _handleTransfer(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes29 _tokenId,\n        bytes29 _action\n    ) internal {\n        // tokens will be sent to the specified recipient\n        address _recipient = _action.evmRecipient();\n        // send tokens\n        _giveTokens(_origin, _nonce, _tokenId, _action, _recipient);\n    }\n\n    // ===== handleUpdateSupply ======\n\n    function _handleUpdateSupply(bytes29 _tokenId, bytes29 _action) internal {\n        address _token = tokenRegistry.ensureLocalToken(\n            _tokenId.domain(),\n            _tokenId.id()\n        );\n\n        require(!tokenRegistry.isLocalOrigin(_token), \"LOCAL_ORIGIN\");\n        ABridgeToken(_token).updateSupply(_action.supply());\n    }\n\n    // ======== Internal Helpers =========\n\n    function _giveTokens(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes29 _tokenId,\n        bytes29 _action,\n        address _recipient\n    ) internal returns (address _token) {\n        // get the token contract for the given tokenId on this chain;\n        // (if the token is of remote origin and there is\n        // no existing representation token contract, the TokenRegistry will\n        // deploy a new one)\n        _token = tokenRegistry.ensureLocalToken(\n            _tokenId.domain(),\n            _tokenId.id()\n        );\n        // load amount once\n        uint256 _amount = _action.amnt();\n        // send the tokens into circulation on this chain\n        if (tokenRegistry.isLocalOrigin(_token)) {\n            // if the token is of local origin, the tokens have been held in\n            // escrow in this contract\n            // while they have been circulating on remote chains;\n            // transfer the tokens to the recipient\n            IERC20(_token).safeTransfer(_recipient, _amount);\n        } else {\n            // if the token is of remote origin, mint the tokens to the\n            // recipient on this chain\n            ABridgeToken(_token).mint(_recipient, _amount);\n            // Tell the token what its detailsHash is\n            ABridgeToken(_token).setDetailsHash(_action.detailsHash());\n        }\n        // emit Receive event\n        emit Receive(\n            _originAndNonce(_origin, _nonce),\n            _token,\n            _recipient,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Take from msg.sender as part of sending tokens across chains\n     * @dev Locks canonical tokens in escrow in BridgeRouter\n     *      OR Burns representation tokens\n     * @param _token The token to pull from the sender\n     * @param _amount The amount to pull from the sender\n     * @return _tokenId the bytes canonical token identifier\n     * @return _detailsHash the hash of the canonical token details (name,\n     *         symbol, decimal)\n     */\n    function _takeTokens(address _token, uint256 _amount)\n        internal\n        returns (bytes29 _tokenId, bytes32 _detailsHash)\n    {\n        // ensure that amount is non-zero\n        require(_amount > 0, \"!amnt\");\n        // Setup vars used in both if branches\n        ABridgeToken _t = ABridgeToken(_token);\n        // remove tokens from circulation on this chain\n        if (tokenRegistry.isLocalOrigin(_token)) {\n            // if the token originates on this chain,\n            // hold the tokens in escrow in the Router\n            IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n            // query token contract for details and calculate detailsHash\n            _detailsHash = BridgeMessage.getDetailsHash(\n                _t.name(),\n                _t.symbol(),\n                _t.decimals()\n            );\n        } else {\n            // if the token originates on a remote chain,\n            // burn the representation tokens on this chain\n            _t.burn(msg.sender, _amount);\n            _detailsHash = _t.detailsHash();\n        }\n        // get the tokenID\n        (uint32 _domain, bytes32 _id) = tokenRegistry.getTokenId(_token);\n        _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n    }\n\n    /**\n     * @notice Dispatch a message via Nomad to a destination domain\n     *         addressed to the remote BridgeRouter on that chain\n     * @dev Message will trigger `handle` method on the remote BridgeRouter\n     *      when it is received on the destination chain\n     * @param _destination The domain of the destination chain\n     * @param _tokenId The canonical token identifier for the transfer message\n     * @param _action The contents of the transfer message\n     */\n    function _sendTransferMessage(\n        uint32 _destination,\n        bytes29 _tokenId,\n        bytes29 _action\n    ) internal {\n        // get remote BridgeRouter address; revert if not found\n        bytes32 _remote = _mustHaveRemote(_destination);\n        // send message to remote chain via Nomad\n        Home(xAppConnectionManager.home()).dispatch(\n            _destination,\n            _remote,\n            BridgeMessage.formatMessage(_tokenId, _action)\n        );\n    }\n\n    // ============ Internal: Utils ============\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     *      we override OpenZeppelin OwnableUpgradeable's\n     *      implementation of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n\n    function _originAndNonce(uint32 _origin, uint32 _nonce)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) << 32) | _nonce;\n    }\n}\n"
    },
    "contracts/BridgeMessage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.15;\n\n// ============ External Imports ============\nimport {TypedMemView} from \"./summa/TypedMemView.sol\";\n\nlibrary BridgeMessage {\n    // ============ Libraries ============\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // ============ Enums ============\n\n    // WARNING: do NOT re-write the numbers / order\n    // of message types in an upgrade;\n    // will cause in-flight messages to be mis-interpreted\n    // The Types enum has to do with the TypedMemView library and it defines\n    // the types of `views` that we use in BridgeMessage. A view is not interesting data\n    // itself, but rather it points to a specific part of the memory where\n    // the data we care about live. When we give a `type` to a view, we define what type\n    // is the data it points to, so that we can do easy runtime assertions without\n    // having to fetch the whole data from memory and check for ourselves. In BridgeMessage.sol\n    // the types of `data` we can have are defined in this enum and may belong to different taxonomies.\n    // For example, a `Message` includes a `TokenId` and an Action, either a `Transfer` or a `TransferToHook`.\n    // The Message is a different TYPE of data than a TokenId or Transfer, as TokenId and Transfer live inside\n    // the message. For that reason, we define them as different data types and we add them to the same enum\n    // for ease of use.\n    enum Types {\n        Invalid, // 0\n        TokenId, // 1\n        Message, // 2\n        Transfer, // 3\n        DeprecatedFastTransfer, // 4\n        TransferToHook, // 5\n        ExtraData, // 6\n        UpdateSupply //7\n    }\n\n    // ============ Structs ============\n\n    // Tokens are identified by a TokenId:\n    // domain - 4 byte chain ID of the chain from which the token originates\n    // id - 32 byte identifier of the token address on the origin chain, in that chain's address format\n    struct TokenId {\n        uint32 domain;\n        bytes32 id;\n    }\n\n    // ============ Constants ============\n\n    uint256 private constant TOKEN_ID_LEN = 36; // 4 bytes domain + 32 bytes id\n    uint256 private constant IDENTIFIER_LEN = 1;\n    uint256 private constant TRANSFER_LEN = 97; // 1 byte identifier + 32 bytes recipient + 32 bytes amount + 32 bytes detailsHash\n    uint256 private constant MIN_TRANSFER_HOOK_LEN = 129; // 1 byte identifier + 32 bytes hook address + 32 bytes amount + 32 bytes detailsHash + 32 bytes sender + X bytes extraData\n    uint256 private constant UPDATE_SUPPLY_LEN = 33; // 1 byte identifier + 32 bytes totalSupply\n\n    // ============ Modifiers ============\n\n    /**\n     * @notice Asserts a message is of type `_t`\n     * @param _view The message\n     * @param _t The expected type\n     */\n    modifier typeAssert(bytes29 _view, Types _t) {\n        _view.assertType(uint40(_t));\n        _;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Checks that Action is valid type\n     * @param _action The action\n     * @return TRUE if action is valid\n     */\n    function isValidAction(bytes29 _action) internal pure returns (bool) {\n        return\n            isTransfer(_action) ||\n            isTransferToHook(_action) ||\n            isUpdateSupply(_action);\n    }\n\n    /**\n     * @notice Checks that view is a valid message length\n     * @param _view The bytes string\n     * @return TRUE if message is valid\n     */\n    function isValidMessageLength(bytes29 _view) internal pure returns (bool) {\n        uint256 _len = _view.len();\n        return\n            _len == TOKEN_ID_LEN + TRANSFER_LEN ||\n            _len >= TOKEN_ID_LEN + MIN_TRANSFER_HOOK_LEN ||\n            _len == TOKEN_ID_LEN + UPDATE_SUPPLY_LEN;\n    }\n\n    /**\n     * @notice Formats an action message\n     * @param _tokenId The token ID\n     * @param _action The action\n     * @return The formatted message\n     */\n    function formatMessage(bytes29 _tokenId, bytes29 _action)\n        internal\n        view\n        typeAssert(_tokenId, Types.TokenId)\n        returns (bytes memory)\n    {\n        require(isValidAction(_action), \"!action\");\n        bytes29[] memory _views = new bytes29[](2);\n        _views[0] = _tokenId;\n        _views[1] = _action;\n        return TypedMemView.join(_views);\n    }\n\n    /**\n     * @notice Returns the type of the message\n     * @param _view The message\n     * @return The type of the message\n     */\n    function messageType(bytes29 _view) internal pure returns (Types) {\n        return Types(uint8(_view.typeOf()));\n    }\n\n    /**\n     * @notice Checks that the message is of the specified type\n     * @param _type the type to check for\n     * @param _action The message\n     * @return True if the message is of the specified type\n     */\n    function isType(bytes29 _action, Types _type) internal pure returns (bool) {\n        return\n            actionType(_action) == uint8(_type) &&\n            messageType(_action) == _type;\n    }\n\n    /**\n     * @notice Checks that the message is of type Transfer\n     * @param _action The message\n     * @return True if the message is of type Transfer\n     */\n    function isTransfer(bytes29 _action) internal pure returns (bool) {\n        return isType(_action, Types.Transfer);\n    }\n\n    /**\n     * @notice Checks that the message is of type TransferToHook\n     * @param _action The message\n     * @return True if the message is of type TransferToHook\n     */\n    function isTransferToHook(bytes29 _action) internal pure returns (bool) {\n        return isType(_action, Types.TransferToHook);\n    }\n\n    /**\n     * @notice Checks that the message is of type UpdateSupply\n     * @param _action The message\n     * @return True if the message is of type Transfer\n     */\n    function isUpdateSupply(bytes29 _action) internal pure returns (bool) {\n        return isType(_action, Types.UpdateSupply);\n    }\n\n    /**\n     * @notice Formats Transfer\n     * @param _to The recipient address as bytes32\n     * @param _amnt The transfer amount\n     * @param _detailsHash The hash of the token name, symbol, and decimals\n     * @return\n     */\n    function formatTransfer(\n        bytes32 _to,\n        uint256 _amnt,\n        bytes32 _detailsHash\n    ) internal pure returns (bytes29) {\n        return\n            abi.encodePacked(Types.Transfer, _to, _amnt, _detailsHash).ref(\n                uint40(Types.Transfer)\n            );\n    }\n\n    /**\n     * @notice Formats TransferToHook message\n     * @param _hook The hook that will handle this token transfer\n     * @param _amnt The transfer amount\n     * @param _detailsHash The hash of the token name, symbol, and decimals\n     * @param _extraData User-provided data for the receiving hook\n     * @return\n     */\n    function formatTransferToHook(\n        bytes32 _hook,\n        uint256 _amnt,\n        bytes32 _detailsHash,\n        bytes32 _sender,\n        bytes memory _extraData\n    ) internal pure returns (bytes29) {\n        return\n            abi\n                .encodePacked(\n                    Types.TransferToHook,\n                    _hook,\n                    _amnt,\n                    _detailsHash,\n                    _sender,\n                    _extraData\n                )\n                .ref(uint40(Types.TransferToHook));\n    }\n\n    /**\n     * @notice Formats UpdateSupply\n     * @param _supply The supply of the token on parent chain\n     * @return\n     */\n    function formatUpdateSupply(uint256 _supply)\n        internal\n        pure\n        returns (bytes29)\n    {\n        return\n            abi.encodePacked(Types.UpdateSupply, _supply).ref(\n                uint40(Types.UpdateSupply)\n            );\n    }\n\n    /**\n     * @notice Serializes a Token ID struct\n     * @param _tokenId The token id struct\n     * @return The formatted Token ID\n     */\n    function formatTokenId(TokenId memory _tokenId)\n        internal\n        pure\n        returns (bytes29)\n    {\n        return formatTokenId(_tokenId.domain, _tokenId.id);\n    }\n\n    /**\n     * @notice Creates a serialized Token ID from components\n     * @param _domain The domain\n     * @param _id The ID\n     * @return The formatted Token ID\n     */\n    function formatTokenId(uint32 _domain, bytes32 _id)\n        internal\n        pure\n        returns (bytes29)\n    {\n        return abi.encodePacked(_domain, _id).ref(uint40(Types.TokenId));\n    }\n\n    /**\n     * @notice Formats the keccak256 hash of the token details\n     * Token Details Format:\n     *      length of name cast to bytes - 32 bytes\n     *      name - x bytes (variable)\n     *      length of symbol cast to bytes - 32 bytes\n     *      symbol - x bytes (variable)\n     *      decimals - 1 byte\n     * @param _name The name\n     * @param _symbol The symbol\n     * @param _decimals The decimals\n     * @return The Details message\n     */\n    function getDetailsHash(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes(_name).length,\n                    _name,\n                    bytes(_symbol).length,\n                    _symbol,\n                    _decimals\n                )\n            );\n    }\n\n    /**\n     * @notice Retrieves the domain from a TokenID\n     * @param _tokenId The message\n     * @return The domain\n     */\n    function domain(bytes29 _tokenId)\n        internal\n        pure\n        typeAssert(_tokenId, Types.TokenId)\n        returns (uint32)\n    {\n        return uint32(_tokenId.indexUint(0, 4));\n    }\n\n    /**\n     * @notice Retrieves the ID from a TokenID\n     * @param _tokenId The message\n     * @return The ID\n     */\n    function id(bytes29 _tokenId)\n        internal\n        pure\n        typeAssert(_tokenId, Types.TokenId)\n        returns (bytes32)\n    {\n        // before = 4 bytes domain\n        return _tokenId.index(4, 32);\n    }\n\n    /**\n     * @notice Retrieves the EVM ID\n     * @param _tokenId The message\n     * @return The EVM ID\n     */\n    function evmId(bytes29 _tokenId)\n        internal\n        pure\n        typeAssert(_tokenId, Types.TokenId)\n        returns (address)\n    {\n        // before = 4 bytes domain + 12 bytes empty to trim for address\n        return _tokenId.indexAddress(16);\n    }\n\n    /**\n     * @notice Retrieves the action identifier from message\n     * @param _message The action\n     * @return The message type\n     */\n    function msgType(bytes29 _message) internal pure returns (uint8) {\n        return uint8(_message.indexUint(TOKEN_ID_LEN, 1));\n    }\n\n    /**\n     * @notice Retrieves the identifier from action\n     * @param _action The action\n     * @return The action type\n     */\n    function actionType(bytes29 _action) internal pure returns (uint8) {\n        return uint8(_action.indexUint(0, 1));\n    }\n\n    /**\n     * @notice Retrieves the recipient from a Transfer\n     * @param _transferAction The message\n     * @return The recipient address as bytes32\n     */\n    function recipient(bytes29 _transferAction)\n        internal\n        pure\n        typeAssert(_transferAction, Types.Transfer)\n        returns (bytes32)\n    {\n        // before = 1 byte identifier\n        return _transferAction.index(1, 32);\n    }\n\n    /**\n     * @notice Retrieves the EVM Recipient from a Transfer\n     * @param _transferAction The message\n     * @return The EVM Recipient\n     */\n    function evmRecipient(bytes29 _transferAction)\n        internal\n        pure\n        typeAssert(_transferAction, Types.Transfer)\n        returns (address)\n    {\n        // before = 1 byte identifier + 12 bytes empty to trim for address = 13 bytes\n        return _transferAction.indexAddress(13);\n    }\n\n    /**\n     * @notice Retrieves the amount from a Transfer\n     * @param _transferAction The message\n     * @return The amount\n     */\n    function amnt(bytes29 _transferAction) internal pure returns (uint256) {\n        // before = 1 byte identifier + 32 bytes ID = 33 bytes\n        return _transferAction.indexUint(33, 32);\n    }\n\n    /**\n     * @notice Retrieves the detailsHash from a Transfer\n     * @param _transferAction The message\n     * @return The detailsHash\n     */\n    function detailsHash(bytes29 _transferAction)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // before = 1 byte identifier + 32 bytes ID + 32 bytes amount = 65 bytes\n        return _transferAction.index(65, 32);\n    }\n\n    /**\n     * @notice Retrieves the token ID from a Message\n     * @param _message The message\n     * @return The ID\n     */\n    function tokenId(bytes29 _message)\n        internal\n        pure\n        typeAssert(_message, Types.Message)\n        returns (bytes29)\n    {\n        return _message.slice(0, TOKEN_ID_LEN, uint40(Types.TokenId));\n    }\n\n    /**\n     * @notice Retrieves the hook contract EVM address from a TransferWithHook\n     * @param _transferAction The message\n     * @return The hook contract address\n     */\n    function evmHook(bytes29 _transferAction)\n        internal\n        pure\n        typeAssert(_transferAction, Types.TransferToHook)\n        returns (address)\n    {\n        return _transferAction.indexAddress(13);\n    }\n\n    /**\n     * @notice Retrieves the sender from a TransferWithHook\n     * @param _transferAction The message\n     * @return The sender as bytes32\n     */\n    function sender(bytes29 _transferAction)\n        internal\n        pure\n        typeAssert(_transferAction, Types.TransferToHook)\n        returns (bytes32)\n    {\n        // before = 1 byte identifier + 32 bytes hook address + 32 bytes amount + 32 bytes detailsHash = 97\n        return _transferAction.index(97, 32);\n    }\n\n    /**\n     * @notice Retrieves the extra data from a TransferWithHook\n     * @param _transferAction The message\n     * @return A TypedMemview of extraData\n     */\n    function extraData(bytes29 _transferAction)\n        internal\n        pure\n        typeAssert(_transferAction, Types.TransferToHook)\n        returns (bytes29)\n    {\n        // anything past the end is the extradata\n        return\n            _transferAction.slice(\n                MIN_TRANSFER_HOOK_LEN,\n                _transferAction.len() - MIN_TRANSFER_HOOK_LEN,\n                uint40(Types.ExtraData)\n            );\n    }\n\n    /**\n     * @notice Retrieves the new supply of the token on parent chain with UpdateSupply action type\n     * @param _updateSupplyAction The message\n     * @return The amount as bytes32\n     */\n    function supply(bytes29 _updateSupplyAction)\n        internal\n        pure\n        typeAssert(_updateSupplyAction, Types.UpdateSupply)\n        returns (uint256)\n    {\n        // before = 1 byte identifier + 32 bytes uint256 supply = 33\n        return _updateSupplyAction.indexUint(33, 32);\n    }\n\n    /**\n     * @notice Retrieves the action data from a Message\n     * @param _message The message\n     * @return The action\n     */\n    function action(bytes29 _message)\n        internal\n        pure\n        typeAssert(_message, Types.Message)\n        returns (bytes29)\n    {\n        uint256 _actionLen = _message.len() - TOKEN_ID_LEN;\n        uint40 _type = uint40(msgType(_message));\n        return _message.slice(TOKEN_ID_LEN, _actionLen, _type);\n    }\n\n    /**\n     * @notice Converts to a Message\n     * @param _message The message\n     * @return The newly typed message\n     */\n    function tryAsMessage(bytes29 _message) internal pure returns (bytes29) {\n        if (isValidMessageLength(_message)) {\n            return _message.castTo(uint40(Types.Message));\n        }\n        return TypedMemView.nullView();\n    }\n\n    /**\n     * @notice Asserts that the message is of type Message\n     * @param _view The message\n     * @return The message\n     */\n    function mustBeMessage(bytes29 _view) internal pure returns (bytes29) {\n        return tryAsMessage(_view).assertValid();\n    }\n}\n"
    },
    "contracts/ABridgeToken.sol": {
      "content": "pragma solidity ^0.8.15;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./AERC20.sol\";\nimport {BridgeMessage} from \"./BridgeMessage.sol\";\n\ncontract ABridgeToken is OwnableUpgradeable, AERC20 {\n    // ============ Immutables ============\n\n    // Immutables used in EIP 712 structured data hashing & signing\n    // https://eips.ethereum.org/EIPS/eip-712\n    bytes32 public immutable _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 private immutable _EIP712_STRUCTURED_DATA_VERSION =\n        keccak256(bytes(\"1\"));\n    uint16 private immutable _EIP712_PREFIX_AND_VERSION = uint16(0x1901);\n\n    // ============ Public Storage ============\n\n    mapping(address => uint256) public nonces;\n    /// @dev hash commitment to the name/symbol/decimals\n    bytes32 public detailsHash;\n\n    // ============ Initializer ============\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    // ============ Events ============\n\n    event UpdateDetails(\n        string indexed name,\n        string indexed symbol,\n        uint8 indexed decimals\n    );\n\n    // ============ External Functions ============\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return token.name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return token.symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return token.decimals;\n    }\n\n    /**\n     * @notice Destroys `_amnt` tokens from `_from`, reducing the\n     * total supply.\n     * @dev Emits a {Transfer} event with `to` set to the zero address.\n     * Requirements:\n     * - `_from` cannot be the zero address.\n     * - `_from` must have at least `_amnt` tokens.\n     * @param _from The address from which to destroy the tokens\n     * @param _amnt The amount of tokens to be destroyed\n     */\n    function burn(address _from, uint256 _amnt) external onlyOwner {\n        _burnShares(_from, _tokensToShares(_amnt));\n    }\n\n    /** @notice Creates `_amnt` tokens and assigns them to `_to`, increasing\n     * the total supply.\n     * @dev Emits a {Transfer} event with `from` set to the zero address.\n     * Requirements:\n     * - `to` cannot be the zero address.\n     * @param _to The destination address\n     * @param _amnt The amount of tokens to be minted\n     */\n    function mint(address _to, uint256 _amnt) external onlyOwner {\n        _mintShares(_to, _tokensToShares(_amnt));\n    }\n\n    /** @notice allows the owner to set the details hash commitment.\n     * @param _detailsHash the new details hash.\n     */\n    function setDetailsHash(bytes32 _detailsHash) external onlyOwner {\n        if (detailsHash != _detailsHash) {\n            detailsHash = _detailsHash;\n        }\n    }\n\n    /**\n     * @notice Set the details of a token\n     * @param _newName The new name\n     * @param _newSymbol The new symbol\n     * @param _newDecimals The new decimals\n     */\n    function setDetails(\n        string calldata _newName,\n        string calldata _newSymbol,\n        uint8 _newDecimals\n    ) external {\n        bool _isFirstDetails = bytes(token.name).length == 0;\n        // 0 case is the initial deploy. We allow the deploying registry to set\n        // these once. After the first transfer is made, detailsHash will be\n        // set, allowing anyone to supply correct name/symbols/decimals\n        require(\n            _isFirstDetails ||\n                BridgeMessage.getDetailsHash(\n                    _newName,\n                    _newSymbol,\n                    _newDecimals\n                ) ==\n                detailsHash,\n            \"!committed details\"\n        );\n        // careful with naming convention change here\n        token.name = _newName;\n        token.symbol = _newSymbol;\n        token.decimals = _newDecimals;\n        if (!_isFirstDetails) {\n            emit UpdateDetails(_newName, _newSymbol, _newDecimals);\n        }\n    }\n\n    /**\n     * @notice Sets approval from owner to spender to value\n     * as long as deadline has not passed\n     * by submitting a valid signature from owner\n     * Uses EIP 712 structured data hashing & signing\n     * https://eips.ethereum.org/EIPS/eip-712\n     * @param _owner The account setting approval & signing the message\n     * @param _spender The account receiving approval to spend owner's tokens\n     * @param _value The amount to set approval for\n     * @param _deadline The timestamp before which the signature must be submitted\n     * @param _v ECDSA signature v\n     * @param _r ECDSA signature r\n     * @param _s ECDSA signature s\n     */\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, \"ERC20Permit: expired deadline\");\n        require(_owner != address(0), \"ERC20Permit: owner zero address\");\n        uint256 _nonce = nonces[_owner];\n        bytes32 _hashStruct = keccak256(\n            abi.encode(\n                _PERMIT_TYPEHASH,\n                _owner,\n                _spender,\n                _value,\n                _nonce,\n                _deadline\n            )\n        );\n        bytes32 _digest = keccak256(\n            abi.encodePacked(\n                _EIP712_PREFIX_AND_VERSION,\n                domainSeparator(),\n                _hashStruct\n            )\n        );\n        address _signer = ecrecover(_digest, _v, _r, _s);\n        require(_signer == _owner, \"ERC20Permit: invalid signature\");\n        nonces[_owner] = _nonce + 1;\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev This is ALWAYS calculated at runtime\n     * because the token name may change\n     */\n    function domainSeparator() public view returns (bytes32) {\n        uint256 _chainId;\n        assembly {\n            _chainId := chainid()\n        }\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(token.name)),\n                    _EIP712_STRUCTURED_DATA_VERSION,\n                    _chainId,\n                    address(this)\n                )\n            );\n    }\n\n    // required for solidity inheritance\n    function transferOwnership(address _newOwner) public override onlyOwner {\n        OwnableUpgradeable.transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin OwnableUpgradeable's\n     * implementation of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n\n    function updateSupply(uint256 _newSupply) external {\n        totalSupply = _newSupply;\n    }\n}\n"
    },
    "contracts/TokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.15;\n\n// ============ Local Contracts ============\nimport {BridgeMessage} from \"./BridgeMessage.sol\";\nimport {Encoding} from \"./utils/Encoding.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ABridgeToken} from \"./ABridgeToken.sol\";\n\n// ============ External Contracts ============\nimport {XAppConnectionClient} from \"./nomad/router/XAppConnectionClient.sol\";\nimport {TypeCasts} from \"./nomad/core/XAppConnectionManager.sol\";\nimport {UpgradeBeaconProxy} from \"./nomad/core/upgrade/UpgradeBeaconProxy.sol\";\nimport {TypedMemView} from \"./summa/TypedMemView.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title TokenRegistry\n * @notice manages a registry of token contracts on this chain\n * -\n * We sort token types as \"representation token\" or \"locally originating token\".\n * Locally originating - a token contract that was originally deployed on the local chain\n * Representation (repr) - a token that was originally deployed on some other chain\n * -\n * When the BridgeRouter handles an incoming message, it determines whether the\n * transfer is for an asset of local origin. If not, it checks for an existing\n * representation contract. If no such representation exists, it deploys a new\n * representation contract. It then stores the relationship in the\n * \"reprToCanonical\" and \"canonicalToRepr\" mappings to ensure we can always\n * perform a lookup in either direction\n * Note that locally originating tokens should NEVER be represented in these lookup tables.\n */\ncontract TokenRegistry is Initializable, XAppConnectionClient {\n    // ============ Libraries ============\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using BridgeMessage for bytes29;\n\n    // ============ Public Storage ============\n\n    // UpgradeBeacon from which new token proxies will get their implementation\n    address public tokenBeacon;\n    // local representation token address => token ID\n    mapping(address => BridgeMessage.TokenId) public representationToCanonical;\n    // hash of the tightly-packed TokenId => local representation token address\n    // If the token is of local origin, this MUST map to address(0).\n    mapping(bytes32 => address) public canonicalToRepresentation;\n\n    // ============ Events ============\n\n    /**\n     * @notice emitted when a representation token contract is deployed\n     * @param domain the domain of the chain where the canonical asset is deployed\n     * @param id the bytes32 address of the canonical token contract\n     * @param representation the address of the newly locally deployed representation contract\n     */\n    event TokenDeployed(\n        uint32 indexed domain,\n        bytes32 indexed id,\n        address indexed representation\n    );\n\n    // ======== Initializer =========\n\n    function initialize(address _tokenBeacon, address _xAppConnectionManager)\n        public\n        initializer\n    {\n        tokenBeacon = _tokenBeacon;\n        __XAppConnectionClient_initialize(_xAppConnectionManager);\n    }\n\n    // ======== TokenId & Address Lookup for Representation Tokens =========\n\n    /**\n     * @notice Look up the canonical token ID for a representation token\n     * @param _representation the address of the representation contract\n     * @return _domain the domain of the canonical version.\n     * @return _id the identifier of the canonical version in its domain.\n     */\n    function getCanonicalTokenId(address _representation)\n        external\n        view\n        returns (uint32 _domain, bytes32 _id)\n    {\n        BridgeMessage.TokenId memory _canonical = representationToCanonical[\n            _representation\n        ];\n        _domain = _canonical.domain;\n        _id = _canonical.id;\n    }\n\n    /**\n     * @notice Look up the representation address for a canonical token\n     * @param _domain the domain of the canonical version.\n     * @param _id the identifier of the canonical version in its domain.\n     * @return _representation the address of the representation contract\n     */\n    function getRepresentationAddress(uint32 _domain, bytes32 _id)\n        public\n        view\n        returns (address _representation)\n    {\n        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n        bytes32 _idHash = _tokenId.keccak();\n        _representation = canonicalToRepresentation[_idHash];\n    }\n\n    // ======== External: Deploying Representation Tokens =========\n\n    /**\n     * @notice Get the address of the local token for the provided tokenId;\n     * if the token is remote and no local representation exists, deploy the representation contract\n     * @param _domain the token's native domain\n     * @param _id the token's id on its native domain\n     * @return _local the address of the local token contract\n     */\n    function ensureLocalToken(uint32 _domain, bytes32 _id)\n        external\n        onlyOwner\n        returns (address _local)\n    {\n        _local = getLocalAddress(_domain, _id);\n        if (_local == address(0)) {\n            // Representation does not exist yet;\n            // deploy representation contract\n            _local = _deployToken(_domain, _id);\n        }\n    }\n\n    // ======== TokenId & Address Lookup for ALL Local Tokens (Representation AND Canonical) =========\n\n    /**\n     * @notice Return tokenId for a local token address\n     * @param _local the local address of the token contract (representation or canonical)\n     * @return _domain canonical domain\n     * @return _id canonical identifier on that domain\n     */\n    function getTokenId(address _local)\n        external\n        view\n        returns (uint32 _domain, bytes32 _id)\n    {\n        BridgeMessage.TokenId memory _tokenId = representationToCanonical[\n            _local\n        ];\n        if (_tokenId.domain == 0) {\n            _domain = _localDomain();\n            _id = TypeCasts.addressToBytes32(_local);\n        } else {\n            _domain = _tokenId.domain;\n            _id = _tokenId.id;\n        }\n    }\n\n    /**\n     * @notice Looks up the local address corresponding to a domain/id pair.\n     * @dev If the token is local, it will return the local address.\n     * If the token is non-local and no local representation exists, this\n     * will return `address(0)`.\n     * @param _domain the domain of the canonical version.\n     * @param _id the identifier of the canonical version in its domain.\n     * @return _local the local address of the token contract (representation or canonical)\n     */\n    function getLocalAddress(uint32 _domain, address _id)\n        external\n        view\n        returns (address _local)\n    {\n        _local = getLocalAddress(_domain, TypeCasts.addressToBytes32(_id));\n    }\n\n    /**\n     * @notice Looks up the local address corresponding to a domain/id pair.\n     * @dev If the token is local, it will return the local address.\n     * If the token is non-local and no local representation exists, this\n     * will return `address(0)`.\n     * @param _domain the domain of the canonical version.\n     * @param _id the identifier of the canonical version in its domain.\n     * @return _local the local address of the token contract (representation or canonical)\n     */\n    function getLocalAddress(uint32 _domain, bytes32 _id)\n        public\n        view\n        returns (address _local)\n    {\n        if (_domain == _localDomain()) {\n            // Token is of local origin\n            _local = TypeCasts.bytes32ToAddress(_id);\n        } else {\n            // Token is a representation of a token of remote origin\n            _local = getRepresentationAddress(_domain, _id);\n        }\n    }\n\n    /**\n     * @notice Return the local token contract for the\n     * canonical tokenId; revert if there is no local token\n     * @param _domain the token's native domain\n     * @param _id the token's id on its native domain\n     * @return the local IERC20 token contract\n     */\n    function mustHaveLocalToken(uint32 _domain, bytes32 _id)\n        external\n        view\n        returns (IERC20)\n    {\n        address _local = getLocalAddress(_domain, _id);\n        require(_local != address(0), \"!token\");\n        return IERC20(_local);\n    }\n\n    /**\n     * @notice Determine if token is of local origin\n     * @return TRUE if token is locally originating\n     */\n    function isLocalOrigin(address _token) external view returns (bool) {\n        // If the contract WAS deployed by the TokenRegistry,\n        // it will be stored in this mapping.\n        // If so, it IS NOT of local origin\n        if (representationToCanonical[_token].domain != 0) {\n            return false;\n        }\n        // If the contract WAS NOT deployed by the TokenRegistry,\n        // and the contract exists, then it IS of local origin\n        // Return true if code exists at _addr\n        uint256 _codeSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _codeSize := extcodesize(_token)\n        }\n        return _codeSize != 0;\n    }\n\n    // ======== Internal Functions =========\n\n    /**\n     * @notice Set the primary representation for a given canonical\n     * @param _domain the domain of the canonical token\n     * @param _id the bytes32 ID pf the canonical of the token\n     * @param _representation the address of the representation token\n     */\n    function _setRepresentationToCanonical(\n        uint32 _domain,\n        bytes32 _id,\n        address _representation\n    ) internal {\n        representationToCanonical[_representation].domain = _domain;\n        representationToCanonical[_representation].id = _id;\n    }\n\n    /**\n     * @notice Set the canonical token for a given representation\n     * @param _domain the domain of the canonical token\n     * @param _id the bytes32 ID pf the canonical of the token\n     * @param _representation the address of the representation token\n     */\n    function _setCanonicalToRepresentation(\n        uint32 _domain,\n        bytes32 _id,\n        address _representation\n    ) internal {\n        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n        bytes32 _idHash = _tokenId.keccak();\n        canonicalToRepresentation[_idHash] = _representation;\n    }\n\n    /**\n     * @notice Deploy and initialize a new token contract\n     * @dev Each token contract is a proxy which\n     * points to the token upgrade beacon\n     * @return _token the address of the token contract\n     */\n    function _deployToken(uint32 _domain, bytes32 _id)\n        internal\n        returns (address _token)\n    {\n        // deploy and initialize the token contract\n        _token = address(new UpgradeBeaconProxy(tokenBeacon, \"\"));\n        // Initialize the token. Normally we initialize during proxy deployment\n        // but due to a proxy quirk, it's clearer to do it explicitly when\n        // calling an initializer with no arguments.\n        ABridgeToken(_token).initialize();\n        // set the default token name & symbol\n        (string memory _name, string memory _symbol) = _defaultDetails(\n            _domain,\n            _id\n        );\n        ABridgeToken(_token).setDetails(_name, _symbol, 18);\n        // transfer ownership to bridgeRouter\n        ABridgeToken(_token).transferOwnership(owner());\n        // store token in mappings\n        _setCanonicalToRepresentation(_domain, _id, _token);\n        _setRepresentationToCanonical(_domain, _id, _token);\n        // emit event upon deploying new token\n        emit TokenDeployed(_domain, _id, _token);\n    }\n\n    /**\n     * @notice Get default name and details for a token\n     *         Sets name to \"[domain].[id]\", and symbol to the first 15\n     *         bytes of the name.\n     * @dev Symbol of 15 bytes is chosen to ensure we don't accidentally break\n     *      the foxy wallet\n     * @param _domain the domain of the canonical token\n     * @param _id the bytes32 ID pf the canonical of the token\n     */\n    function _defaultDetails(uint32 _domain, bytes32 _id)\n        internal\n        pure\n        returns (string memory _name, string memory _symbol)\n    {\n        // get the first and second half of the token ID\n        (, uint256 _secondHalfId) = Encoding.encodeHex(uint256(_id));\n        // encode the default token name: \"[decimal domain].[hex 4 bytes of ID]\"\n        _name = string(\n            abi.encodePacked(\n                Encoding.decimalUint32(_domain), // 10\n                \".\", // 1\n                uint32(_secondHalfId) // 4\n            )\n        );\n        // allocate the memory for a new 15-byte string\n        _symbol = new string(10 + 1 + 4);\n        assembly {\n            mstore(add(_symbol, 0x20), mload(add(_name, 0x20)))\n        }\n    }\n\n    /**\n     * @dev explicit override for compiler inheritance\n     * @dev explicit override for compiler inheritance\n     * @return domain of chain on which the contract is deployed\n     */\n    function _localDomain()\n        internal\n        view\n        override(XAppConnectionClient)\n        returns (uint32)\n    {\n        return XAppConnectionClient._localDomain();\n    }\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin OwnableUpgradeable's\n     * implementation of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n}\n"
    },
    "contracts/nomad/router/XAppConnectionClient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ External Imports ============\nimport {Home} from \"../core/Home.sol\";\nimport {XAppConnectionManager} from \"../core/XAppConnectionManager.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract XAppConnectionClient is OwnableUpgradeable {\n    // ============ Mutable Storage ============\n\n    XAppConnectionManager public xAppConnectionManager;\n    uint256[49] private __GAP; // gap for upgrade safety\n\n    // ============ Modifiers ============\n\n    /**\n     * @notice Only accept messages from an Nomad Replica contract\n     */\n    modifier onlyReplica() {\n        require(_isReplica(msg.sender), \"!replica\");\n        _;\n    }\n\n    // ======== Initializer =========\n\n    function __XAppConnectionClient_initialize(address _xAppConnectionManager)\n        internal\n    {\n        xAppConnectionManager = XAppConnectionManager(_xAppConnectionManager);\n        __Ownable_init();\n    }\n\n    // ============ External functions ============\n\n    /**\n     * @notice Modify the contract the xApp uses to validate Replica contracts\n     * @param _xAppConnectionManager The address of the xAppConnectionManager contract\n     */\n    function setXAppConnectionManager(address _xAppConnectionManager)\n        external\n        onlyOwner\n    {\n        xAppConnectionManager = XAppConnectionManager(_xAppConnectionManager);\n    }\n\n    // ============ Internal functions ============\n\n    /**\n     * @notice Get the local Home contract from the xAppConnectionManager\n     * @return The local Home contract\n     */\n    function _home() internal view returns (Home) {\n        return xAppConnectionManager.home();\n    }\n\n    /**\n     * @notice Determine whether _potentialReplica is an enrolled Replica from the xAppConnectionManager\n     * @param _potentialReplica The candidate to be tested. Violently.\n     * @return True if _potentialReplica is an enrolled Replica\n     */\n    function _isReplica(address _potentialReplica)\n        internal\n        view\n        returns (bool)\n    {\n        return xAppConnectionManager.isReplica(_potentialReplica);\n    }\n\n    /**\n     * @notice Get the local domain from the xAppConnectionManager\n     * @return The local domain\n     */\n    function _localDomain() internal view virtual returns (uint32) {\n        return xAppConnectionManager.localDomain();\n    }\n}\n"
    },
    "contracts/nomad/router/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {XAppConnectionClient} from \"./XAppConnectionClient.sol\";\n// ============ External Imports ============\nimport {IMessageRecipient} from \"../core/interfaces/IMessageRecipient.sol\";\n\nabstract contract Router is XAppConnectionClient, IMessageRecipient {\n    // ============ Mutable Storage ============\n\n    mapping(uint32 => bytes32) public remotes;\n    uint256[49] private __GAP; // gap for upgrade safety\n\n    // ============ Modifiers ============\n\n    /**\n     * @notice Only accept messages from a remote Router contract\n     * @param _origin The domain the message is coming from\n     * @param _router The address the message is coming from\n     */\n    modifier onlyRemoteRouter(uint32 _origin, bytes32 _router) {\n        require(_isRemoteRouter(_origin, _router), \"!remote router\");\n        _;\n    }\n\n    // ============ External functions ============\n\n    /**\n     * @notice Register the address of a Router contract for the same xApp on a remote chain\n     * @param _domain The domain of the remote xApp Router\n     * @param _router The address of the remote xApp Router\n     */\n    function enrollRemoteRouter(uint32 _domain, bytes32 _router)\n        external\n        onlyOwner\n    {\n        remotes[_domain] = _router;\n    }\n\n    // ============ Virtual functions ============\n\n    function handle(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes32 _sender,\n        bytes memory _message\n    ) external virtual override;\n\n    // ============ Internal functions ============\n    /**\n     * @notice Return true if the given domain / router is the address of a remote xApp Router\n     * @param _domain The domain of the potential remote xApp Router\n     * @param _router The address of the potential remote xApp Router\n     */\n    function _isRemoteRouter(uint32 _domain, bytes32 _router)\n        internal\n        view\n        returns (bool)\n    {\n        return remotes[_domain] == _router && _router != bytes32(0);\n    }\n\n    /**\n     * @notice Assert that the given domain has a xApp Router registered and return its address\n     * @param _domain The domain of the chain for which to get the xApp Router\n     * @return _remote The address of the remote xApp Router on _domain\n     */\n    function _mustHaveRemote(uint32 _domain)\n        internal\n        view\n        returns (bytes32 _remote)\n    {\n        _remote = remotes[_domain];\n        require(_remote != bytes32(0), \"!remote\");\n    }\n}\n"
    },
    "contracts/nomad/core/Home.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {Version0} from \"./Version0.sol\";\nimport {NomadBase} from \"./NomadBase.sol\";\nimport {QueueLib} from \"./libs/Queue.sol\";\nimport {MerkleLib} from \"./libs/Merkle.sol\";\nimport {Message} from \"./libs/Message.sol\";\nimport {MerkleTreeManager} from \"./Merkle.sol\";\nimport {QueueManager} from \"./Queue.sol\";\nimport {IUpdaterManager} from \"./interfaces/IUpdaterManager.sol\";\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Home\n * @author Illusory Systems Inc.\n * @notice Accepts messages to be dispatched to remote chains,\n * constructs a Merkle tree of the messages,\n * and accepts signatures from a bonded Updater\n * which notarize the Merkle tree roots.\n * Accepts submissions of fraudulent signatures\n * by the Updater and slashes the Updater in this case.\n */\ncontract Home is Version0, QueueManager, MerkleTreeManager, NomadBase {\n    // ============ Libraries ============\n\n    using QueueLib for QueueLib.Queue;\n    using MerkleLib for MerkleLib.Tree;\n\n    // ============ Constants ============\n\n    // Maximum bytes per message = 2 KiB\n    // (somewhat arbitrarily set to begin)\n    uint256 public constant MAX_MESSAGE_BODY_BYTES = 2 * 2**10;\n\n    // ============ Public Storage Variables ============\n\n    // domain => next available nonce for the domain\n    mapping(uint32 => uint32) public nonces;\n    // contract responsible for Updater bonding, slashing and rotation\n    IUpdaterManager public updaterManager;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[48] private __GAP;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted when a new message is dispatched via Nomad\n     * @param messageHash Hash of message; the leaf inserted to the Merkle tree\n     *        for the message\n     * @param leafIndex Index of message's leaf in merkle tree\n     * @param destinationAndNonce Destination and destination-specific\n     *        nonce combined in single field ((destination << 32) & nonce)\n     * @param committedRoot the latest notarized root submitted in the last\n     *        signed Update\n     * @param message Raw bytes of message\n     */\n    event Dispatch(\n        bytes32 indexed messageHash,\n        uint256 indexed leafIndex,\n        uint64 indexed destinationAndNonce,\n        bytes32 committedRoot,\n        bytes message\n    );\n\n    /**\n     * @notice Emitted when proof of an improper update is submitted,\n     * which sets the contract to FAILED state\n     * @param oldRoot Old root of the improper update\n     * @param newRoot New root of the improper update\n     * @param signature Signature on `oldRoot` and `newRoot\n     */\n    event ImproperUpdate(bytes32 oldRoot, bytes32 newRoot, bytes signature);\n\n    /**\n     * @notice Emitted when proof of a double update is submitted,\n     * which sets the contract to FAILED state\n     * @param oldRoot Old root shared between two conflicting updates\n     * @param newRoot Array containing two conflicting new roots\n     * @param signature Signature on `oldRoot` and `newRoot`[0]\n     * @param signature2 Signature on `oldRoot` and `newRoot`[1]\n     */\n    event DoubleUpdate(\n        bytes32 oldRoot,\n        bytes32[2] newRoot,\n        bytes signature,\n        bytes signature2\n    );\n\n    /**\n     * @notice Emitted when the Updater is slashed\n     * (should be paired with ImproperUpdater or DoubleUpdate event)\n     * @param updater The address of the updater\n     * @param reporter The address of the entity that reported the updater misbehavior\n     */\n    event UpdaterSlashed(address indexed updater, address indexed reporter);\n\n    /**\n     * @notice Emitted when the UpdaterManager contract is changed\n     * @param updaterManager The address of the new updaterManager\n     */\n    event NewUpdaterManager(address updaterManager);\n\n    // ============ Constructor ============\n\n    constructor(uint32 _localDomain) NomadBase(_localDomain) {} // solhint-disable-line no-empty-blocks\n\n    // ============ Initializer ============\n\n    function initialize(IUpdaterManager _updaterManager) public initializer {\n        // initialize queue, set Updater Manager, and initialize\n        __QueueManager_initialize();\n        _setUpdaterManager(_updaterManager);\n        __NomadBase_initialize(updaterManager.updater());\n    }\n\n    // ============ Modifiers ============\n\n    /**\n     * @notice Ensures that function is called by the UpdaterManager contract\n     */\n    modifier onlyUpdaterManager() {\n        require(msg.sender == address(updaterManager), \"!updaterManager\");\n        _;\n    }\n\n    /**\n     * @notice Ensures that contract state != FAILED when the function is called\n     */\n    modifier notFailed() {\n        require(state != States.Failed, \"failed state\");\n        _;\n    }\n\n    // ============ External: Updater & UpdaterManager Configuration  ============\n\n    /**\n     * @notice Set a new Updater\n     * @dev To be set when rotating Updater after Fraud\n     * @param _updater the new Updater\n     */\n    function setUpdater(address _updater) external onlyUpdaterManager {\n        _setUpdater(_updater);\n        // set the Home state to Active\n        // now that Updater has been rotated\n        state = States.Active;\n    }\n\n    /**\n     * @notice Set a new UpdaterManager contract\n     * @dev Home(s) will initially be initialized using a trusted UpdaterManager contract;\n     * we will progressively decentralize by swapping the trusted contract with a new implementation\n     * that implements Updater bonding & slashing, and rules for Updater selection & rotation\n     * @param _updaterManager the new UpdaterManager contract\n     */\n    function setUpdaterManager(address _updaterManager) external onlyOwner {\n        _setUpdaterManager(IUpdaterManager(_updaterManager));\n    }\n\n    // ============ External Functions  ============\n\n    /**\n     * @notice Dispatch the message to the destination domain & recipient\n     * @dev Format the message, insert its hash into Merkle tree,\n     * enqueue the new Merkle root, and emit `Dispatch` event with message information.\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipientAddress Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes content of message\n     */\n    function dispatch(\n        uint32 _destinationDomain,\n        bytes32 _recipientAddress,\n        bytes memory _messageBody\n    ) external notFailed {\n        require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n        // get the next nonce for the destination domain, then increment it\n        uint32 _nonce = nonces[_destinationDomain];\n        nonces[_destinationDomain] = _nonce + 1;\n        // format the message into packed bytes\n        bytes memory _message = Message.formatMessage(\n            localDomain,\n            bytes32(uint256(uint160(msg.sender))),\n            _nonce,\n            _destinationDomain,\n            _recipientAddress,\n            _messageBody\n        );\n        // insert the hashed message into the Merkle tree\n        bytes32 _messageHash = keccak256(_message);\n        tree.insert(_messageHash);\n        // enqueue the new Merkle root after inserting the message\n        queue.enqueue(root());\n        // Emit Dispatch event with message information\n        // note: leafIndex is count() - 1 since new leaf has already been inserted\n        emit Dispatch(\n            _messageHash,\n            count() - 1,\n            _destinationAndNonce(_destinationDomain, _nonce),\n            committedRoot,\n            _message\n        );\n    }\n\n    /**\n     * @notice Submit a signature from the Updater \"notarizing\" a root,\n     * which updates the Home contract's `committedRoot`,\n     * and publishes the signature which will be relayed to Replica contracts\n     * @dev emits Update event\n     * @dev If _newRoot is not contained in the queue,\n     * the Update is a fraudulent Improper Update, so\n     * the Updater is slashed & Home is set to FAILED state\n     * @param _committedRoot Current updated merkle root which the update is building off of\n     * @param _newRoot New merkle root to update the contract state to\n     * @param _signature Updater signature on `_committedRoot` and `_newRoot`\n     */\n    function update(\n        bytes32 _committedRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) external notFailed {\n        // check that the update is not fraudulent;\n        // if fraud is detected, Updater is slashed & Home is set to FAILED state\n        if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\n        // clear all of the intermediate roots contained in this update from the queue\n        while (true) {\n            bytes32 _next = queue.dequeue();\n            if (_next == _newRoot) break;\n        }\n        // update the Home state with the latest signed root & emit event\n        committedRoot = _newRoot;\n        emit Update(localDomain, _committedRoot, _newRoot, _signature);\n    }\n\n    /**\n     * @notice Suggest an update for the Updater to sign and submit.\n     * @dev If queue is empty, null bytes returned for both\n     * (No update is necessary because no messages have been dispatched since the last update)\n     * @return _committedRoot Latest root signed by the Updater\n     * @return _new Latest enqueued Merkle root\n     */\n    function suggestUpdate()\n        external\n        view\n        returns (bytes32 _committedRoot, bytes32 _new)\n    {\n        if (queue.length() != 0) {\n            _committedRoot = committedRoot;\n            _new = queue.lastItem();\n        }\n    }\n\n    /**\n     * @notice Called by external agent. Checks that signatures on two sets of\n     * roots are valid and that the new roots conflict with each other. If both\n     * cases hold true, the contract is failed and a `DoubleUpdate` event is\n     * emitted.\n     * @dev When `fail()` is called on Home, updater is slashed.\n     * @param _oldRoot Old root shared between two conflicting updates\n     * @param _newRoot Array containing two conflicting new roots\n     * @param _signature Signature on `_oldRoot` and `_newRoot`[0]\n     * @param _signature2 Signature on `_oldRoot` and `_newRoot`[1]\n     */\n    function doubleUpdate(\n        bytes32 _oldRoot,\n        bytes32[2] calldata _newRoot,\n        bytes calldata _signature,\n        bytes calldata _signature2\n    ) external notFailed {\n        if (\n            NomadBase._isUpdaterSignature(_oldRoot, _newRoot[0], _signature) &&\n            NomadBase._isUpdaterSignature(_oldRoot, _newRoot[1], _signature2) &&\n            _newRoot[0] != _newRoot[1]\n        ) {\n            _fail();\n            emit DoubleUpdate(_oldRoot, _newRoot, _signature, _signature2);\n        }\n    }\n\n    // ============ Public Functions  ============\n\n    /**\n     * @notice Hash of Home domain concatenated with \"NOMAD\"\n     */\n    function homeDomainHash() public view override returns (bytes32) {\n        return _homeDomainHash(localDomain);\n    }\n\n    /**\n     * @notice Check if an Update is an Improper Update;\n     * if so, slash the Updater and set the contract to FAILED state.\n     *\n     * An Improper Update is an update building off of the Home's `committedRoot`\n     * for which the `_newRoot` does not currently exist in the Home's queue.\n     * This would mean that message(s) that were not truly\n     * dispatched on Home were falsely included in the signed root.\n     *\n     * An Improper Update will only be accepted as valid by the Replica\n     * If an Improper Update is attempted on Home,\n     * the Updater will be slashed immediately.\n     * If an Improper Update is submitted to the Replica,\n     * it should be relayed to the Home contract using this function\n     * in order to slash the Updater with an Improper Update.\n     *\n     * An Improper Update submitted to the Replica is only valid\n     * while the `_oldRoot` is still equal to the `committedRoot` on Home;\n     * if the `committedRoot` on Home has already been updated with a valid Update,\n     * then the Updater should be slashed with a Double Update.\n     * @dev Reverts (and doesn't slash updater) if signature is invalid or\n     * update not current\n     * @param _oldRoot Old merkle tree root (should equal home's committedRoot)\n     * @param _newRoot New merkle tree root\n     * @param _signature Updater signature on `_oldRoot` and `_newRoot`\n     * @return TRUE if update was an Improper Update (implying Updater was slashed)\n     */\n    function improperUpdate(\n        bytes32 _oldRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) public notFailed returns (bool) {\n        require(\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n            \"!updater sig\"\n        );\n        require(_oldRoot == committedRoot, \"not a current update\");\n        // if the _newRoot is not currently contained in the queue,\n        // slash the Updater and set the contract to FAILED state\n        if (!queue.contains(_newRoot)) {\n            _fail();\n            emit ImproperUpdate(_oldRoot, _newRoot, _signature);\n            return true;\n        }\n        // if the _newRoot is contained in the queue,\n        // this is not an improper update\n        return false;\n    }\n\n    // ============ Internal Functions  ============\n\n    /**\n     * @notice Set the UpdaterManager\n     * @param _updaterManager Address of the UpdaterManager\n     */\n    function _setUpdaterManager(IUpdaterManager _updaterManager) internal {\n        require(\n            Address.isContract(address(_updaterManager)),\n            \"!contract updaterManager\"\n        );\n        updaterManager = IUpdaterManager(_updaterManager);\n        emit NewUpdaterManager(address(_updaterManager));\n    }\n\n    /**\n     * @notice Slash the Updater and set contract state to FAILED\n     * @dev Called when fraud is proven (Improper Update or Double Update)\n     */\n    function _fail() internal {\n        // set contract to FAILED\n        state = States.Failed;\n        // slash Updater\n        updaterManager.slashUpdater(payable(msg.sender));\n        emit UpdaterSlashed(updater, msg.sender);\n    }\n\n    /**\n     * @notice Internal utility function that combines\n     * `_destination` and `_nonce`.\n     * @dev Both destination and nonce should be less than 2^32 - 1\n     * @param _destination Domain of destination chain\n     * @param _nonce Current nonce for given destination chain\n     * @return Returns (`_destination` << 32) & `_nonce`\n     */\n    function _destinationAndNonce(uint32 _destination, uint32 _nonce)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_destination) << 32) | _nonce;\n    }\n}\n"
    },
    "contracts/nomad/core/libs/TypeCasts.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\nimport \"../../../summa/TypedMemView.sol\";\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s)\n        internal\n        pure\n        returns (bytes32 _b)\n    {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf)\n        internal\n        pure\n        returns (string memory _newStr)\n    {\n        uint8 _slen = 0;\n        while (_slen < 32 && _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n"
    },
    "contracts/summa/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary TypedMemView {\n    using SafeMath for uint256;\n\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL =\n        hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\n        encoded <<= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b)\n        internal\n        pure\n        returns (uint256 first, uint256 second)\n    {\n        for (uint8 i = 31; i > 15; i -= 1) {\n            uint8 _byte = uint8(_b >> (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first <<= 16;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i < 255; i -= 1) {\n            uint8 _byte = uint8(_b >> (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second <<= 16;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v >> 8) &\n                0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v &\n                0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) <<\n                8);\n        // swap 2-byte long pairs\n        v =\n            ((v >> 16) &\n                0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v &\n                0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) <<\n                16);\n        // swap 4-byte long pairs\n        v =\n            ((v >> 32) &\n                0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v &\n                0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) <<\n                32);\n        // swap 8-byte long pairs\n        v =\n            ((v >> 64) &\n                0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v &\n                0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) <<\n                64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected)\n        internal\n        pure\n        returns (bool)\n    {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected)\n        internal\n        pure\n        returns (bytes29)\n    {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType)\n        internal\n        pure\n        returns (bytes29 newView)\n    {\n        // then | in the new type\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc.add(_len);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType)\n        internal\n        pure\n        returns (bytes29)\n    {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right)\n        internal\n        pure\n        returns (bool)\n    {\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return uint256(len(memView)).add(32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        return loc(memView) + len(memView);\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc.add(_index).add(_len) > end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc.add(_index);\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index.add(_bytes) > len(memView)) {\n            revert(\n                indexErrOverrun(\n                    loc(memView),\n                    len(memView),\n                    _index,\n                    uint256(_bytes)\n                )\n            );\n        }\n        require(\n            _bytes <= 32,\n            \"TypedMemView/index - Attempted to index more than 32 bytes\"\n        );\n\n        uint8 bitLength = _bytes * 8;\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index)\n        internal\n        pure\n        returns (address)\n    {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right)\n        internal\n        pure\n        returns (bool)\n    {\n        return\n            (loc(left) == loc(right) && len(left) == len(right)) ||\n            keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right)\n        internal\n        pure\n        returns (bool)\n    {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            left == right ||\n            (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right)\n        internal\n        pure\n        returns (bool)\n    {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc)\n        private\n        view\n        returns (bytes29 written)\n    {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(\n            isValid(memView),\n            \"TypedMemView/copyTo - Invalid pointer deref\"\n        );\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unsafeCopyTo(memView, ptr + 0x20);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i < memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unsafeCopyTo(memView, _location + _offset);\n            _offset += len(memView);\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews)\n        internal\n        view\n        returns (bytes32)\n    {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews)\n        internal\n        view\n        returns (bytes32)\n    {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews)\n        internal\n        view\n        returns (bytes memory ret)\n    {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/AERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ncontract AERC20 {\n    /**\n     * @notice Transfer gets emitted when TenderTokens are transferred.\n     * @param from the account that tokens are transferred from\n     * @param to the account that tokens are transferred to\n     * @param amount the amount of tokens transferred\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice Approve gets emitted when TenderTokens are approved for spending.\n     * @param owner the account tokens are approved from\n     * @param spender the account tokens are approved to\n     * @param amount the amount of tokens approved\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    struct Token {\n        string symbol;\n        string name;\n        uint8 decimals;\n    }\n\n    Token internal token;\n\n    /**\n     * @dev Total supply of token\n     * @dev Controlled by Tenderizer\n     * @notice Total amount of tokens staked\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @dev Total amount of outstanding shares\n     */\n    uint256 public totalShares;\n\n    /**\n     * @dev Shares of all accounts.\n     * @dev tokens = shares * totalSupply / totalShares;\n     */\n    mapping(address => uint256) public shares;\n\n    /**\n     * @dev Allowances nominated in tokens, not token shares.\n     */\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /**\n     * @param _account Account whose balance is requested.\n     * @dev Returns the amount of tokens (amount represented by shares) owned by `_account`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return _sharesToTokens(shares[_account]);\n    }\n\n    /**\n     * @param _spender account to approve tokens for spending.\n     * @param _amount token ammount to approve for spending.\n     * @return success boolean value indicating whether the operation succeeded.\n     * @dev Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     * @dev Emits an `Approval` event.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        return _approve(msg.sender, _spender, _amount);\n    }\n\n    /**\n     * @param _spender account to increase token allowance for spending.\n     * @param _addedValue token ammount to add to existing allowance.\n     * @return success boolean value indicating whether the operation succeeded.\n     * @dev Increases allowance by `_amount` for `spender` over the caller's tokens.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        returns (bool)\n    {\n        allowance[msg.sender][_spender] += _addedValue;\n        return true;\n    }\n\n    /**\n     * @param _spender account to increase token allowance for spending.\n     * @param _subtractedValue token ammount to subtract from existing allowance.\n     * @return success boolean value indicating whether the operation succeeded.\n     * @dev Reduces allowance by `_amount` for `spender` over the caller's tokens.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        returns (bool)\n    {\n        allowance[msg.sender][_spender] -= _subtractedValue;\n        return true;\n    }\n\n    /**\n     * @notice Transfers `_amount` tokens from the caller's account to the `_to` account.\n     * @param _to address of the recipient\n     * @param _amount amount of tokens to transfer\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _to, uint256 _amount)\n        public\n        returns (bool success)\n    {\n        success = _transferShares(msg.sender, _to, _tokensToShares(_amount));\n        emit Transfer(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Transfers `_amount` tokens from `_from` to `_to` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's allowance.\n     * @param _from address of the account to transfer tokens from\n     * @param _to address of the recipient\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev Reduces allowance bt `_amount`\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns (bool success) {\n        // Underflow if not enough allowance\n        allowance[_from][msg.sender] -= _amount;\n        success = _transferShares(_from, _to, _tokensToShares(_amount));\n        emit Transfer(_from, _to, _amount);\n    }\n\n    // Internal functions\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) internal returns (bool) {\n        allowance[_owner][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves `_shares` shares from `_from` to `_to`.\n     * @dev `_from` must hold at least `_shares` shares.\n     * @return success a boolean value indicating whether the operation succeeded.\n     */\n    function _transferShares(\n        address _from,\n        address _to,\n        uint256 _shares\n    ) private returns (bool) {\n        shares[_from] -= _shares;\n        // unchecked as bound by totalShares hence cannot overflow\n        shares[_to] += _shares;\n        return true;\n    }\n\n    /**\n     * @dev Creates `_sharesToMint` shares and assigns them to `_account`, increasing the total amount of shares.\n     * @dev This doesn't increase the token total supply.\n     */\n    function _mintShares(address _account, uint256 _sharesToMint) internal {\n        totalShares += _sharesToMint;\n        shares[_account] += _sharesToMint;\n    }\n\n    /**\n     * @dev Destroys `_sharesToBurn` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     * @dev `_account` must hold at least `_sharesToBurn` shares.\n     */\n    function _burnShares(address _account, uint256 _sharesToBurn) internal {\n        // Underflow if not enough shares to burn\n        shares[_account] -= _sharesToBurn;\n        totalShares -= _sharesToBurn;\n    }\n\n    function _sharesToTokens(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalShares = totalShares;\n        if (_totalShares == 0) return 0;\n        return (_shares * totalSupply) / _totalShares;\n    }\n\n    function _tokensToShares(uint256 _tokens) internal view returns (uint256) {\n        uint256 _totalSupply = totalSupply;\n        uint256 _totalShares = totalShares;\n        if (_totalShares == 0) return _tokens;\n        if (_totalSupply == 0) return 0;\n        return (_tokens * _totalShares) / _totalSupply;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.15;\n\nlibrary Encoding {\n    // ============ Constants ============\n\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Encode a uint32 in its DECIMAL representation, with leading\n     * zeroes.\n     * @param _num The number to encode\n     * @return _encoded The encoded number, suitable for use in abi.\n     * encodePacked\n     */\n    function decimalUint32(uint32 _num)\n        internal\n        pure\n        returns (uint80 _encoded)\n    {\n        uint80 ASCII_0 = 0x30;\n        // all over/underflows are impossible\n        // this will ALWAYS produce 10 decimal characters\n        for (uint8 i = 0; i < 10; i += 1) {\n            _encoded |= ((_num % 10) + ASCII_0) << (i * 8);\n            _num = _num / 10;\n        }\n    }\n\n    /**\n     * @notice Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     * `second` contains the encoded lower 16 bytes.\n     * @param _bytes The 32 bytes as uint256\n     * @return _firstHalf The top 16 bytes\n     * @return _secondHalf The bottom 16 bytes\n     */\n    function encodeHex(uint256 _bytes)\n        internal\n        pure\n        returns (uint256 _firstHalf, uint256 _secondHalf)\n    {\n        for (uint8 i = 31; i > 15; i -= 1) {\n            uint8 _b = uint8(_bytes >> (i * 8));\n            _firstHalf |= _byteHex(_b);\n            if (i != 16) {\n                _firstHalf <<= 16;\n            }\n        }\n        // abusing underflow here =_=\n        for (uint8 i = 15; i < 255; i -= 1) {\n            uint8 _b = uint8(_bytes >> (i * 8));\n            _secondHalf |= _byteHex(_b);\n            if (i != 0) {\n                _secondHalf <<= 16;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte The byte\n     * @return _char The encoded hex character\n     */\n    function _nibbleHex(uint8 _byte) private pure returns (uint8 _char) {\n        uint8 _nibble = _byte & 0x0f; // keep bottom 4, 0 top 4\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice Returns a uint16 containing the hex-encoded byte.\n     * @param _byte The byte\n     * @return _encoded The hex-encoded byte\n     */\n    function _byteHex(uint8 _byte) private pure returns (uint16 _encoded) {\n        _encoded |= _nibbleHex(_byte >> 4); // top 4 bits\n        _encoded <<= 8;\n        _encoded |= _nibbleHex(_byte); // lower 4 bits\n    }\n}\n"
    },
    "contracts/nomad/core/XAppConnectionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {Home} from \"./Home.sol\";\nimport {Replica} from \"./Replica.sol\";\nimport {TypeCasts} from \"./libs/TypeCasts.sol\";\n// ============ External Imports ============\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title XAppConnectionManager\n * @author Illusory Systems Inc.\n * @notice Manages a registry of local Replica contracts\n * for remote Home domains. Accepts Watcher signatures\n * to un-enroll Replicas attached to fraudulent remote Homes\n */\ncontract XAppConnectionManager is Ownable {\n    // ============ Public Storage ============\n\n    // Home contract\n    Home public home;\n    // local Replica address => remote Home domain\n    mapping(address => uint32) public replicaToDomain;\n    // remote Home domain => local Replica address\n    mapping(uint32 => address) public domainToReplica;\n    // watcher address => replica remote domain => has/doesn't have permission\n    mapping(address => mapping(uint32 => bool)) private watcherPermissions;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted when a new Replica is enrolled / added\n     * @param domain the remote domain of the Home contract for the Replica\n     * @param replica the address of the Replica\n     */\n    event ReplicaEnrolled(uint32 indexed domain, address replica);\n\n    /**\n     * @notice Emitted when a new Replica is un-enrolled / removed\n     * @param domain the remote domain of the Home contract for the Replica\n     * @param replica the address of the Replica\n     */\n    event ReplicaUnenrolled(uint32 indexed domain, address replica);\n\n    /**\n     * @notice Emitted when Watcher permissions are changed\n     * @param domain the remote domain of the Home contract for the Replica\n     * @param watcher the address of the Watcher\n     * @param access TRUE if the Watcher was given permissions, FALSE if permissions were removed\n     */\n    event WatcherPermissionSet(\n        uint32 indexed domain,\n        address watcher,\n        bool access\n    );\n\n    // ============ Constructor ============\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() Ownable() {}\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Un-Enroll a replica contract\n     * in the case that fraud was detected on the Home\n     * @dev in the future, if fraud occurs on the Home contract,\n     * the Watcher will submit their signature directly to the Home\n     * and it can be relayed to all remote chains to un-enroll the Replicas\n     * @param _domain the remote domain of the Home contract for the Replica\n     * @param _updater the address of the Updater for the Home contract (also stored on Replica)\n     * @param _signature signature of watcher on (domain, replica address, updater address)\n     */\n    function unenrollReplica(\n        uint32 _domain,\n        bytes32 _updater,\n        bytes memory _signature\n    ) external {\n        // ensure that the replica is currently set\n        address _replica = domainToReplica[_domain];\n        require(_replica != address(0), \"!replica exists\");\n        // ensure that the signature is on the proper updater\n        require(\n            Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater),\n            \"!current updater\"\n        );\n        // get the watcher address from the signature\n        // and ensure that the watcher has permission to un-enroll this replica\n        address _watcher = _recoverWatcherFromSig(\n            _domain,\n            TypeCasts.addressToBytes32(_replica),\n            _updater,\n            _signature\n        );\n        require(watcherPermissions[_watcher][_domain], \"!valid watcher\");\n        // remove the replica from mappings\n        _unenrollReplica(_replica);\n    }\n\n    /**\n     * @notice Set the address of the local Home contract\n     * @param _home the address of the local Home contract\n     */\n    function setHome(address _home) external onlyOwner {\n        home = Home(_home);\n    }\n\n    /**\n     * @notice Allow Owner to enroll Replica contract\n     * @param _replica the address of the Replica\n     * @param _domain the remote domain of the Home contract for the Replica\n     */\n    function ownerEnrollReplica(address _replica, uint32 _domain)\n        external\n        onlyOwner\n    {\n        // un-enroll any existing replica\n        _unenrollReplica(_replica);\n        // add replica and domain to two-way mapping\n        replicaToDomain[_replica] = _domain;\n        domainToReplica[_domain] = _replica;\n        emit ReplicaEnrolled(_domain, _replica);\n    }\n\n    /**\n     * @notice Allow Owner to un-enroll Replica contract\n     * @param _replica the address of the Replica\n     */\n    function ownerUnenrollReplica(address _replica) external onlyOwner {\n        _unenrollReplica(_replica);\n    }\n\n    /**\n     * @notice Allow Owner to set Watcher permissions for a Replica\n     * @param _watcher the address of the Watcher\n     * @param _domain the remote domain of the Home contract for the Replica\n     * @param _access TRUE to give the Watcher permissions, FALSE to remove permissions\n     */\n    function setWatcherPermission(\n        address _watcher,\n        uint32 _domain,\n        bool _access\n    ) external onlyOwner {\n        watcherPermissions[_watcher][_domain] = _access;\n        emit WatcherPermissionSet(_domain, _watcher, _access);\n    }\n\n    /**\n     * @notice Query local domain from Home\n     * @return local domain\n     */\n    function localDomain() external view returns (uint32) {\n        return home.localDomain();\n    }\n\n    /**\n     * @notice Get access permissions for the watcher on the domain\n     * @param _watcher the address of the watcher\n     * @param _domain the domain to check for watcher permissions\n     * @return TRUE iff _watcher has permission to un-enroll replicas on _domain\n     */\n    function watcherPermission(address _watcher, uint32 _domain)\n        external\n        view\n        returns (bool)\n    {\n        return watcherPermissions[_watcher][_domain];\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Check whether _replica is enrolled\n     * @param _replica the replica to check for enrollment\n     * @return TRUE iff _replica is enrolled\n     */\n    function isReplica(address _replica) public view returns (bool) {\n        return replicaToDomain[_replica] != 0;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Remove the replica from the two-way mappings\n     * @param _replica replica to un-enroll\n     */\n    function _unenrollReplica(address _replica) internal {\n        uint32 _currentDomain = replicaToDomain[_replica];\n        domainToReplica[_currentDomain] = address(0);\n        replicaToDomain[_replica] = 0;\n        emit ReplicaUnenrolled(_currentDomain, _replica);\n    }\n\n    /**\n     * @notice Get the Watcher address from the provided signature\n     * @return address of watcher that signed\n     */\n    function _recoverWatcherFromSig(\n        uint32 _domain,\n        bytes32 _replica,\n        bytes32 _updater,\n        bytes memory _signature\n    ) internal view returns (address) {\n        bytes32 _homeDomainHash = Replica(TypeCasts.bytes32ToAddress(_replica))\n            .homeDomainHash();\n        bytes32 _digest = keccak256(\n            abi.encodePacked(_homeDomainHash, _domain, _updater)\n        );\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\n        return ECDSA.recover(_digest, _signature);\n    }\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin Ownable implementation\n     * of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n}\n"
    },
    "contracts/nomad/core/upgrade/UpgradeBeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeaconProxy\n * @notice\n * Proxy contract which delegates all logic, including initialization,\n * to an implementation contract.\n * The implementation contract is stored within an Upgrade Beacon contract;\n * the implementation contract can be changed by performing an upgrade on the Upgrade Beacon contract.\n * The Upgrade Beacon contract for this Proxy is immutably specified at deployment.\n * @dev This implementation combines the gas savings of keeping the UpgradeBeacon address outside of contract storage\n * found in 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\n * With the added safety checks that the UpgradeBeacon and implementation are contracts at time of deployment\n * found in OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol\n */\ncontract UpgradeBeaconProxy {\n    // ============ Immutables ============\n\n    // Upgrade Beacon address is immutable (therefore not kept in contract storage)\n    address private immutable upgradeBeacon;\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Validate that the Upgrade Beacon is a contract, then set its\n     * address immutably within this contract.\n     * Validate that the implementation is also a contract,\n     * Then call the initialization function defined at the implementation.\n     * The deployment will revert and pass along the\n     * revert reason if the initialization function reverts.\n     * @param _upgradeBeacon Address of the Upgrade Beacon to be stored immutably in the contract\n     * @param _initializationCalldata Calldata supplied when calling the initialization function\n     */\n    constructor(address _upgradeBeacon, bytes memory _initializationCalldata)\n        payable\n    {\n        // Validate the Upgrade Beacon is a contract\n        require(Address.isContract(_upgradeBeacon), \"beacon !contract\");\n        // set the Upgrade Beacon\n        upgradeBeacon = _upgradeBeacon;\n        // Validate the implementation is a contract\n        address _implementation = _getImplementation(_upgradeBeacon);\n        require(\n            Address.isContract(_implementation),\n            \"beacon implementation !contract\"\n        );\n        // Call the initialization function on the implementation\n        if (_initializationCalldata.length > 0) {\n            _initialize(_implementation, _initializationCalldata);\n        }\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Forwards all calls with data to _fallback()\n     * No public functions are declared on the contract, so all calls hit fallback\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @notice Forwards all calls with no data to _fallback()\n     */\n    receive() external payable {\n        _fallback();\n    }\n\n    // ============ Private Functions ============\n\n    /**\n     * @notice Call the initialization function on the implementation\n     * Used at deployment to initialize the proxy\n     * based on the logic for initialization defined at the implementation\n     * @param _implementation - Contract to which the initalization is delegated\n     * @param _initializationCalldata - Calldata supplied when calling the initialization function\n     */\n    function _initialize(\n        address _implementation,\n        bytes memory _initializationCalldata\n    ) private {\n        // Delegatecall into the implementation, supplying initialization calldata.\n        (bool _ok, ) = _implementation.delegatecall(_initializationCalldata);\n        // Revert and include revert data if delegatecall to implementation reverts.\n        if (!_ok) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Delegates function calls to the implementation contract returned by the Upgrade Beacon\n     */\n    function _fallback() private {\n        _delegate(_getImplementation());\n    }\n\n    /**\n     * @notice Delegate function execution to the implementation contract\n     * @dev This is a low level function that doesn't return to its internal\n     * call site. It will return whatever is returned by the implementation to the\n     * external caller, reverting and returning the revert data if implementation\n     * reverts.\n     * @param _implementation - Address to which the function execution is delegated\n     */\n    function _delegate(address _implementation) private {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n            // Delegatecall to the implementation, supplying calldata and gas.\n            // Out and outsize are set to zero - instead, use the return buffer.\n            let result := delegatecall(\n                gas(),\n                _implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            // Copy the returned data from the return buffer.\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            // Delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Call the Upgrade Beacon to get the current implementation contract address\n     * @return _implementation Address of the current implementation.\n     */\n    function _getImplementation()\n        private\n        view\n        returns (address _implementation)\n    {\n        _implementation = _getImplementation(upgradeBeacon);\n    }\n\n    /**\n     * @notice Call the Upgrade Beacon to get the current implementation contract address\n     * @dev _upgradeBeacon is passed as a parameter so that\n     * we can also use this function in the constructor,\n     * where we can't access immutable variables.\n     * @param _upgradeBeacon Address of the UpgradeBeacon storing the current implementation\n     * @return _implementation Address of the current implementation.\n     */\n    function _getImplementation(address _upgradeBeacon)\n        private\n        view\n        returns (address _implementation)\n    {\n        // Get the current implementation address from the upgrade beacon.\n        (bool _ok, bytes memory _returnData) = _upgradeBeacon.staticcall(\"\");\n        // Revert and pass along revert message if call to upgrade beacon reverts.\n        require(_ok, string(_returnData));\n        // Set the implementation to the address returned from the upgrade beacon.\n        _implementation = abi.decode(_returnData, (address));\n    }\n}\n"
    },
    "contracts/nomad/core/Version0.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n/**\n * @title Version0\n * @notice Version getter for contracts\n **/\nabstract contract Version0 {\n    uint8 public constant VERSION = 0;\n}\n"
    },
    "contracts/nomad/core/NomadBase.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {Message} from \"./libs/Message.sol\";\n// ============ External Imports ============\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title NomadBase\n * @author Illusory Systems Inc.\n * @notice Shared utilities between Home and Replica.\n */\nabstract contract NomadBase is Initializable, OwnableUpgradeable {\n    // ============ Enums ============\n\n    // States:\n    //   0 - UnInitialized - before initialize function is called\n    //   note: the contract is initialized at deploy time, so it should never be in this state\n    //   1 - Active - as long as the contract has not become fraudulent\n    //   2 - Failed - after a valid fraud proof has been submitted;\n    //   contract will no longer accept updates or new messages\n    enum States {\n        UnInitialized,\n        Active,\n        Failed\n    }\n\n    // ============ Immutable Variables ============\n\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // ============ Public Variables ============\n\n    // Address of bonded Updater\n    address public updater;\n    // Current state of contract\n    States public state;\n    // The latest root that has been signed by the Updater\n    bytes32 public committedRoot;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[47] private __GAP;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted when update is made on Home\n     * or unconfirmed update root is submitted on Replica\n     * @param homeDomain Domain of home contract\n     * @param oldRoot Old merkle root\n     * @param newRoot New merkle root\n     * @param signature Updater's signature on `oldRoot` and `newRoot`\n     */\n    event Update(\n        uint32 indexed homeDomain,\n        bytes32 indexed oldRoot,\n        bytes32 indexed newRoot,\n        bytes signature\n    );\n\n    /**\n     * @notice Emitted when Updater is rotated\n     * @param oldUpdater The address of the old updater\n     * @param newUpdater The address of the new updater\n     */\n    event NewUpdater(address oldUpdater, address newUpdater);\n\n    // ============ Constructor ============\n\n    constructor(uint32 _localDomain) {\n        localDomain = _localDomain;\n    }\n\n    // ============ Initializer ============\n\n    function __NomadBase_initialize(address _updater) internal initializer {\n        __Ownable_init();\n        _setUpdater(_updater);\n        state = States.Active;\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Hash of Home domain concatenated with \"NOMAD\"\n     */\n    function homeDomainHash() public view virtual returns (bytes32);\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Hash of Home domain concatenated with \"NOMAD\"\n     * @param _homeDomain the Home domain to hash\n     */\n    function _homeDomainHash(uint32 _homeDomain)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_homeDomain, \"NOMAD\"));\n    }\n\n    /**\n     * @notice Set the Updater\n     * @param _newUpdater Address of the new Updater\n     */\n    function _setUpdater(address _newUpdater) internal {\n        address _oldUpdater = updater;\n        updater = _newUpdater;\n        emit NewUpdater(_oldUpdater, _newUpdater);\n    }\n\n    /**\n     * @notice Checks that signature was signed by Updater\n     * @param _oldRoot Old merkle root\n     * @param _newRoot New merkle root\n     * @param _signature Signature on `_oldRoot` and `_newRoot`\n     * @return TRUE iff signature is valid signed by updater\n     **/\n    function _isUpdaterSignature(\n        bytes32 _oldRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) internal view returns (bool) {\n        bytes32 _digest = keccak256(\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\n        );\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\n        return (ECDSA.recover(_digest, _signature) == updater);\n    }\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin OwnableUpgradeable's\n     * implementation of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n}\n"
    },
    "contracts/nomad/core/libs/Queue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n/**\n * @title QueueLib\n * @author Illusory Systems Inc.\n * @notice Library containing queue struct and operations for queue used by\n * Home and Replica.\n **/\nlibrary QueueLib {\n    /**\n     * @notice Queue struct\n     * @dev Internally keeps track of the `first` and `last` elements through\n     * indices and a mapping of indices to enqueued elements.\n     **/\n    struct Queue {\n        uint128 first;\n        uint128 last;\n        mapping(uint256 => bytes32) queue;\n    }\n\n    /**\n     * @notice Initializes the queue\n     * @dev Empty state denoted by _q.first > q._last. Queue initialized\n     * with _q.first = 1 and _q.last = 0.\n     **/\n    function initialize(Queue storage _q) internal {\n        if (_q.first == 0) {\n            _q.first = 1;\n        }\n    }\n\n    /**\n     * @notice Enqueues a single new element\n     * @param _item New element to be enqueued\n     * @return _last Index of newly enqueued element\n     **/\n    function enqueue(Queue storage _q, bytes32 _item)\n        internal\n        returns (uint128 _last)\n    {\n        _last = _q.last + 1;\n        _q.last = _last;\n        if (_item != bytes32(0)) {\n            // saves gas if we're queueing 0\n            _q.queue[_last] = _item;\n        }\n    }\n\n    /**\n     * @notice Dequeues element at front of queue\n     * @dev Removes dequeued element from storage\n     * @return _item Dequeued element\n     **/\n    function dequeue(Queue storage _q) internal returns (bytes32 _item) {\n        uint128 _last = _q.last;\n        uint128 _first = _q.first;\n        require(_length(_last, _first) != 0, \"Empty\");\n        _item = _q.queue[_first];\n        if (_item != bytes32(0)) {\n            // saves gas if we're dequeuing 0\n            delete _q.queue[_first];\n        }\n        _q.first = _first + 1;\n    }\n\n    /**\n     * @notice Batch enqueues several elements\n     * @param _items Array of elements to be enqueued\n     * @return _last Index of last enqueued element\n     **/\n    function enqueue(Queue storage _q, bytes32[] memory _items)\n        internal\n        returns (uint128 _last)\n    {\n        _last = _q.last;\n        for (uint256 i = 0; i < _items.length; i += 1) {\n            _last += 1;\n            bytes32 _item = _items[i];\n            if (_item != bytes32(0)) {\n                _q.queue[_last] = _item;\n            }\n        }\n        _q.last = _last;\n    }\n\n    /**\n     * @notice Batch dequeues `_number` elements\n     * @dev Reverts if `_number` > queue length\n     * @param _number Number of elements to dequeue\n     * @return Array of dequeued elements\n     **/\n    function dequeue(Queue storage _q, uint256 _number)\n        internal\n        returns (bytes32[] memory)\n    {\n        uint128 _last = _q.last;\n        uint128 _first = _q.first;\n        // Cannot underflow unless state is corrupted\n        require(_length(_last, _first) >= _number, \"Insufficient\");\n\n        bytes32[] memory _items = new bytes32[](_number);\n\n        for (uint256 i = 0; i < _number; i++) {\n            _items[i] = _q.queue[_first];\n            delete _q.queue[_first];\n            _first++;\n        }\n        _q.first = _first;\n        return _items;\n    }\n\n    /**\n     * @notice Returns true if `_item` is in the queue and false if otherwise\n     * @dev Linearly scans from _q.first to _q.last looking for `_item`\n     * @param _item Item being searched for in queue\n     * @return True if `_item` currently exists in queue, false if otherwise\n     **/\n    function contains(Queue storage _q, bytes32 _item)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i = _q.first; i <= _q.last; i++) {\n            if (_q.queue[i] == _item) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Returns last item in queue\n    /// @dev Returns bytes32(0) if queue empty\n    function lastItem(Queue storage _q) internal view returns (bytes32) {\n        return _q.queue[_q.last];\n    }\n\n    /// @notice Returns element at front of queue without removing element\n    /// @dev Reverts if queue is empty\n    function peek(Queue storage _q) internal view returns (bytes32 _item) {\n        require(!isEmpty(_q), \"Empty\");\n        _item = _q.queue[_q.first];\n    }\n\n    /// @notice Returns true if queue is empty and false if otherwise\n    function isEmpty(Queue storage _q) internal view returns (bool) {\n        return _q.last < _q.first;\n    }\n\n    /// @notice Returns number of elements in queue\n    function length(Queue storage _q) internal view returns (uint256) {\n        uint128 _last = _q.last;\n        uint128 _first = _q.first;\n        // Cannot underflow unless state is corrupted\n        return _length(_last, _first);\n    }\n\n    /// @notice Returns number of elements between `_last` and `_first` (used internally)\n    function _length(uint128 _last, uint128 _first)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(_last + 1 - _first);\n    }\n}\n"
    },
    "contracts/nomad/core/libs/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// work based on eth2 deposit contract, which is used under CC0-1.0\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n **/\nlibrary MerkleLib {\n    uint256 internal constant TREE_DEPTH = 32;\n    uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\n\n    /**\n     * @notice Struct representing incremental merkle tree. Contains current\n     * branch and the number of inserted leaves in the tree.\n     **/\n    struct Tree {\n        bytes32[TREE_DEPTH] branch;\n        uint256 count;\n    }\n\n    /**\n     * @notice Inserts `_node` into merkle tree\n     * @dev Reverts if tree is full\n     * @param _node Element to insert into tree\n     **/\n    function insert(Tree storage _tree, bytes32 _node) internal {\n        require(_tree.count < MAX_LEAVES, \"merkle tree full\");\n\n        _tree.count += 1;\n        uint256 size = _tree.count;\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n            if ((size & 1) == 1) {\n                _tree.branch[i] = _node;\n                return;\n            }\n            _node = keccak256(abi.encodePacked(_tree.branch[i], _node));\n            size /= 2;\n        }\n        // As the loop should always end prematurely with the `return` statement,\n        // this code should be unreachable. We assert `false` just to be safe.\n        assert(false);\n    }\n\n    /**\n     * @notice Calculates and returns`_tree`'s current root given array of zero\n     * hashes\n     * @param _zeroes Array of zero hashes\n     * @return _current Calculated root of `_tree`\n     **/\n    function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\n        internal\n        view\n        returns (bytes32 _current)\n    {\n        uint256 _index = _tree.count;\n\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n            uint256 _ithBit = (_index >> i) & 0x01;\n            bytes32 _next = _tree.branch[i];\n            if (_ithBit == 1) {\n                _current = keccak256(abi.encodePacked(_next, _current));\n            } else {\n                _current = keccak256(abi.encodePacked(_current, _zeroes[i]));\n            }\n        }\n    }\n\n    /// @notice Calculates and returns`_tree`'s current root\n    function root(Tree storage _tree) internal view returns (bytes32) {\n        return rootWithCtx(_tree, zeroHashes());\n    }\n\n    /// @notice Returns array of TREE_DEPTH zero hashes\n    /// @return _zeroes Array of TREE_DEPTH zero hashes\n    function zeroHashes()\n        internal\n        pure\n        returns (bytes32[TREE_DEPTH] memory _zeroes)\n    {\n        _zeroes[0] = Z_0;\n        _zeroes[1] = Z_1;\n        _zeroes[2] = Z_2;\n        _zeroes[3] = Z_3;\n        _zeroes[4] = Z_4;\n        _zeroes[5] = Z_5;\n        _zeroes[6] = Z_6;\n        _zeroes[7] = Z_7;\n        _zeroes[8] = Z_8;\n        _zeroes[9] = Z_9;\n        _zeroes[10] = Z_10;\n        _zeroes[11] = Z_11;\n        _zeroes[12] = Z_12;\n        _zeroes[13] = Z_13;\n        _zeroes[14] = Z_14;\n        _zeroes[15] = Z_15;\n        _zeroes[16] = Z_16;\n        _zeroes[17] = Z_17;\n        _zeroes[18] = Z_18;\n        _zeroes[19] = Z_19;\n        _zeroes[20] = Z_20;\n        _zeroes[21] = Z_21;\n        _zeroes[22] = Z_22;\n        _zeroes[23] = Z_23;\n        _zeroes[24] = Z_24;\n        _zeroes[25] = Z_25;\n        _zeroes[26] = Z_26;\n        _zeroes[27] = Z_27;\n        _zeroes[28] = Z_28;\n        _zeroes[29] = Z_29;\n        _zeroes[30] = Z_30;\n        _zeroes[31] = Z_31;\n    }\n\n    /**\n     * @notice Calculates and returns the merkle root for the given leaf\n     * `_item`, a merkle branch, and the index of `_item` in the tree.\n     * @param _item Merkle leaf\n     * @param _branch Merkle proof\n     * @param _index Index of `_item` in tree\n     * @return _current Calculated merkle root\n     **/\n    function branchRoot(\n        bytes32 _item,\n        bytes32[TREE_DEPTH] memory _branch,\n        uint256 _index\n    ) internal pure returns (bytes32 _current) {\n        _current = _item;\n\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\n            uint256 _ithBit = (_index >> i) & 0x01;\n            bytes32 _next = _branch[i];\n            if (_ithBit == 1) {\n                _current = keccak256(abi.encodePacked(_next, _current));\n            } else {\n                _current = keccak256(abi.encodePacked(_current, _next));\n            }\n        }\n    }\n\n    // keccak256 zero hashes\n    bytes32 internal constant Z_0 =\n        hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    bytes32 internal constant Z_1 =\n        hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n    bytes32 internal constant Z_2 =\n        hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n    bytes32 internal constant Z_3 =\n        hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n    bytes32 internal constant Z_4 =\n        hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n    bytes32 internal constant Z_5 =\n        hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n    bytes32 internal constant Z_6 =\n        hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n    bytes32 internal constant Z_7 =\n        hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n    bytes32 internal constant Z_8 =\n        hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n    bytes32 internal constant Z_9 =\n        hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n    bytes32 internal constant Z_10 =\n        hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n    bytes32 internal constant Z_11 =\n        hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n    bytes32 internal constant Z_12 =\n        hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n    bytes32 internal constant Z_13 =\n        hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n    bytes32 internal constant Z_14 =\n        hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n    bytes32 internal constant Z_15 =\n        hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n    bytes32 internal constant Z_16 =\n        hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n    bytes32 internal constant Z_17 =\n        hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n    bytes32 internal constant Z_18 =\n        hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n    bytes32 internal constant Z_19 =\n        hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n    bytes32 internal constant Z_20 =\n        hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n    bytes32 internal constant Z_21 =\n        hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n    bytes32 internal constant Z_22 =\n        hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n    bytes32 internal constant Z_23 =\n        hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n    bytes32 internal constant Z_24 =\n        hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n    bytes32 internal constant Z_25 =\n        hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n    bytes32 internal constant Z_26 =\n        hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n    bytes32 internal constant Z_27 =\n        hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n    bytes32 internal constant Z_28 =\n        hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n    bytes32 internal constant Z_29 =\n        hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n    bytes32 internal constant Z_30 =\n        hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n    bytes32 internal constant Z_31 =\n        hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n}\n"
    },
    "contracts/nomad/core/libs/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\nimport \"../../../summa/TypedMemView.sol\";\n\nimport {TypeCasts} from \"./TypeCasts.sol\";\n\n/**\n * @title Message Library\n * @author Illusory Systems Inc.\n * @notice Library for formatted messages used by Home and Replica.\n **/\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Number of bytes in formatted message before `body` field\n    uint256 internal constant PREFIX_LENGTH = 76;\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _originDomain Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        bytes memory _body\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                formatMessage(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _body\n                )\n            );\n    }\n\n    /// @notice Returns message's origin field\n    function origin(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(0, 4));\n    }\n\n    /// @notice Returns message's sender field\n    function sender(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(4, 32);\n    }\n\n    /// @notice Returns message's nonce field\n    function nonce(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(36, 4));\n    }\n\n    /// @notice Returns message's destination field\n    function destination(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(40, 4));\n    }\n\n    /// @notice Returns message's recipient field as bytes32\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(44, 32);\n    }\n\n    /// @notice Returns message's recipient field as an address\n    function recipientAddress(bytes29 _message)\n        internal\n        pure\n        returns (address)\n    {\n        return TypeCasts.bytes32ToAddress(recipient(_message));\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure returns (bytes29) {\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n    }\n\n    function leaf(bytes29 _message) internal view returns (bytes32) {\n        return\n            messageHash(\n                origin(_message),\n                sender(_message),\n                nonce(_message),\n                destination(_message),\n                recipient(_message),\n                TypedMemView.clone(body(_message))\n            );\n    }\n}\n"
    },
    "contracts/nomad/core/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {MerkleLib} from \"./libs/Merkle.sol\";\n\n/**\n * @title MerkleTreeManager\n * @author Illusory Systems Inc.\n * @notice Contains a Merkle tree instance and\n * exposes view functions for the tree.\n */\ncontract MerkleTreeManager {\n    // ============ Libraries ============\n\n    using MerkleLib for MerkleLib.Tree;\n    MerkleLib.Tree public tree;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[49] private __GAP;\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Calculates and returns tree's current root\n     */\n    function root() public view returns (bytes32) {\n        return tree.root();\n    }\n\n    /**\n     * @notice Returns the number of inserted leaves in the tree (current index)\n     */\n    function count() public view returns (uint256) {\n        return tree.count;\n    }\n}\n"
    },
    "contracts/nomad/core/Queue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {QueueLib} from \"./libs/Queue.sol\";\n// ============ External Imports ============\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title QueueManager\n * @author Illusory Systems Inc.\n * @notice Contains a queue instance and\n * exposes view functions for the queue.\n **/\ncontract QueueManager is Initializable {\n    // ============ Libraries ============\n\n    using QueueLib for QueueLib.Queue;\n    QueueLib.Queue internal queue;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[49] private __GAP;\n\n    // ============ Initializer ============\n\n    function __QueueManager_initialize() internal initializer {\n        queue.initialize();\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Returns number of elements in queue\n     */\n    function queueLength() external view returns (uint256) {\n        return queue.length();\n    }\n\n    /**\n     * @notice Returns TRUE iff `_item` is in the queue\n     */\n    function queueContains(bytes32 _item) external view returns (bool) {\n        return queue.contains(_item);\n    }\n\n    /**\n     * @notice Returns last item enqueued to the queue\n     */\n    function queueEnd() external view returns (bytes32) {\n        return queue.lastItem();\n    }\n}\n"
    },
    "contracts/nomad/core/interfaces/IUpdaterManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\ninterface IUpdaterManager {\n    function slashUpdater(address payable _reporter) external;\n\n    function updater() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/nomad/core/Replica.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {Version0} from \"./Version0.sol\";\nimport {NomadBase} from \"./NomadBase.sol\";\nimport {MerkleLib} from \"./libs/Merkle.sol\";\nimport {Message} from \"./libs/Message.sol\";\nimport {IMessageRecipient} from \"./interfaces/IMessageRecipient.sol\";\n// ============ External Imports ============\nimport {TypedMemView} from \"../../summa/TypedMemView.sol\";\n\n/**\n * @title Replica\n * @author Illusory Systems Inc.\n * @notice Track root updates on Home,\n * prove and dispatch messages to end recipients.\n */\ncontract Replica is Version0, NomadBase {\n    // ============ Libraries ============\n\n    using MerkleLib for MerkleLib.Tree;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ Constants ============\n\n    bytes32 public constant LEGACY_STATUS_NONE = bytes32(0);\n    bytes32 public constant LEGACY_STATUS_PROVEN = bytes32(uint256(1));\n    bytes32 public constant LEGACY_STATUS_PROCESSED = bytes32(uint256(2));\n\n    // ============ Public Storage ============\n\n    // Domain of home chain\n    uint32 public remoteDomain;\n    // Number of seconds to wait before root becomes confirmable\n    uint256 public optimisticSeconds;\n    // re-entrancy guard\n    uint8 private entered;\n    // Mapping of roots to allowable confirmation times\n    mapping(bytes32 => uint256) public confirmAt;\n    // Mapping of message leaves to MessageStatus\n    mapping(bytes32 => bytes32) public messages;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[45] private __GAP;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted when message is processed\n     * @param messageHash The keccak256 hash of the message that was processed\n     * @param success TRUE if the call was executed successfully,\n     * FALSE if the call reverted or threw\n     * @param returnData the return data from the external call\n     */\n    event Process(\n        bytes32 indexed messageHash,\n        bool indexed success,\n        bytes indexed returnData\n    );\n\n    /**\n     * @notice Emitted when the value for optimisticTimeout is set\n     * @param timeout The new value for optimistic timeout\n     */\n    event SetOptimisticTimeout(uint256 timeout);\n\n    /**\n     * @notice Emitted when a root's confirmation is modified by governance\n     * @param root The root for which confirmAt has been set\n     * @param previousConfirmAt The previous value of confirmAt\n     * @param newConfirmAt The new value of confirmAt\n     */\n    event SetConfirmation(\n        bytes32 indexed root,\n        uint256 previousConfirmAt,\n        uint256 newConfirmAt\n    );\n\n    // ============ Constructor ============\n\n    constructor(uint32 _localDomain) NomadBase(_localDomain) {}\n\n    // ============ Initializer ============\n\n    /**\n     * @notice Initialize the replica\n     * @dev Performs the following action:\n     *      - initializes inherited contracts\n     *      - initializes re-entrancy guard\n     *      - sets remote domain\n     *      - sets a trusted root, and pre-approves messages under it\n     *      - sets the optimistic timer\n     * @param _remoteDomain The domain of the Home contract this follows\n     * @param _updater The EVM id of the updater\n     * @param _committedRoot A trusted root from which to start the Replica\n     * @param _optimisticSeconds The time a new root must wait to be confirmed\n     */\n    function initialize(\n        uint32 _remoteDomain,\n        address _updater,\n        bytes32 _committedRoot,\n        uint256 _optimisticSeconds\n    ) public initializer {\n        __NomadBase_initialize(_updater);\n        // set storage variables\n        entered = 1;\n        remoteDomain = _remoteDomain;\n        committedRoot = _committedRoot;\n        // pre-approve the committed root.\n        if (_committedRoot != bytes32(0)) confirmAt[_committedRoot] = 1;\n        _setOptimisticTimeout(_optimisticSeconds);\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Called by external agent. Submits the signed update's new root,\n     * marks root's allowable confirmation time, and emits an `Update` event.\n     * @dev Reverts if update doesn't build off latest committedRoot\n     * or if signature is invalid.\n     * @param _oldRoot Old merkle root\n     * @param _newRoot New merkle root\n     * @param _signature Updater's signature on `_oldRoot` and `_newRoot`\n     */\n    function update(\n        bytes32 _oldRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) external {\n        // ensure that update is building off the last submitted root\n        require(_oldRoot == committedRoot, \"not current update\");\n        // validate updater signature\n        require(\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n            \"!updater sig\"\n        );\n        // Hook for future use\n        _beforeUpdate();\n        // set the new root's confirmation timer\n        confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n        // update committedRoot\n        committedRoot = _newRoot;\n        emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n    }\n\n    /**\n     * @notice If necessary, attempts to prove the validity of provided\n     *         `_message`. If the message is successfully proven, then tries to\n     *         process the message\n     * @dev Reverts if `prove` call returns false\n     * @param _message A Nomad message coming from another chain :)\n     * @param _proof Merkle proof of inclusion for message's leaf (optional if\n     *        the message has already been proven).\n     * @param _index Index of leaf in home's merkle tree (optional if the\n     *        message has already been proven).\n     */\n    function proveAndProcess(\n        bytes memory _message,\n        bytes32[32] calldata _proof,\n        uint256 _index\n    ) external {\n        bytes32 _messageHash = keccak256(_message);\n        require(\n            acceptableRoot(messages[_messageHash]) ||\n                prove(_messageHash, _proof, _index),\n            \"!prove\"\n        );\n        process(_message);\n    }\n\n    /**\n     * @notice Given formatted message, attempts to dispatch\n     * message payload to end recipient.\n     * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\n     * Reverts if formatted message's destination domain is not the Replica's domain,\n     * if message has not been proven,\n     * or if not enough gas is provided for the dispatch transaction.\n     * @param _message Formatted message\n     * @return _success TRUE iff dispatch transaction succeeded\n     */\n    function process(bytes memory _message) public returns (bool _success) {\n        // ensure message was meant for this domain\n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        // ensure message has been proven\n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        // check re-entrancy guard\n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        // update message status as processed\n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        // call handle function\n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        // emit process results\n        emit Process(_messageHash, true, \"\");\n        // reset re-entrancy guard\n        entered = 1;\n        // return true\n        return true;\n    }\n\n    // ============ External Owner Functions ============\n\n    /**\n     * @notice Set optimistic timeout period for new roots\n     * @dev Only callable by owner (Governance)\n     * @param _optimisticSeconds New optimistic timeout period\n     */\n    function setOptimisticTimeout(uint256 _optimisticSeconds)\n        external\n        onlyOwner\n    {\n        _setOptimisticTimeout(_optimisticSeconds);\n    }\n\n    /**\n     * @notice Set Updater role\n     * @dev MUST ensure that all roots signed by previous Updater have\n     * been relayed before calling. Only callable by owner (Governance)\n     * @param _updater New Updater\n     */\n    function setUpdater(address _updater) external onlyOwner {\n        _setUpdater(_updater);\n    }\n\n    /**\n     * @notice Set confirmAt for a given root\n     * @dev To be used if in the case that fraud is proven\n     * and roots need to be deleted / added. Only callable by owner (Governance)\n     * @param _root The root for which to modify confirm time\n     * @param _confirmAt The new confirmation time. Set to 0 to \"delete\" a root.\n     */\n    function setConfirmation(bytes32 _root, uint256 _confirmAt)\n        external\n        onlyOwner\n    {\n        uint256 _previousConfirmAt = confirmAt[_root];\n        confirmAt[_root] = _confirmAt;\n        emit SetConfirmation(_root, _previousConfirmAt, _confirmAt);\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Check that the root has been submitted\n     * and that the optimistic timeout period has expired,\n     * meaning the root can be processed\n     * @param _root the Merkle root, submitted in an update, to check\n     * @return TRUE iff root has been submitted & timeout has expired\n     */\n    function acceptableRoot(bytes32 _root) public view returns (bool) {\n        // this is backwards-compatibility for messages proven/processed\n        // under previous versions\n        if (_root == LEGACY_STATUS_PROVEN) return true;\n        if (_root == LEGACY_STATUS_PROCESSED || _root == LEGACY_STATUS_NONE)\n            return false;\n\n        uint256 _time = confirmAt[_root];\n        if (_time == 0) {\n            return false;\n        }\n        return block.timestamp >= _time;\n    }\n\n    /**\n     * @notice Attempts to prove the validity of message given its leaf, the\n     * merkle proof of inclusion for the leaf, and the index of the leaf.\n     * @dev Reverts if message's MessageStatus != None (i.e. if message was\n     * already proven or processed)\n     * @dev For convenience, we allow proving against any previous root.\n     * This means that witnesses never need to be updated for the new root\n     * @param _leaf Leaf of message to prove\n     * @param _proof Merkle proof of inclusion for leaf\n     * @param _index Index of leaf in home's merkle tree\n     * @return Returns true if proof was valid and `prove` call succeeded\n     **/\n    function prove(\n        bytes32 _leaf,\n        bytes32[32] calldata _proof,\n        uint256 _index\n    ) public returns (bool) {\n        // ensure that message has not been processed\n        // Note that this allows re-proving under a new root.\n        require(\n            messages[_leaf] != LEGACY_STATUS_PROCESSED,\n            \"already processed\"\n        );\n        // calculate the expected root based on the proof\n        bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\n        // if the root is valid, change status to Proven\n        if (acceptableRoot(_calculatedRoot)) {\n            messages[_leaf] = _calculatedRoot;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Hash of Home domain concatenated with \"NOMAD\"\n     */\n    function homeDomainHash() public view override returns (bytes32) {\n        return _homeDomainHash(remoteDomain);\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Set optimistic timeout period for new roots\n     * @dev Called by owner (Governance) or at initialization\n     * @param _optimisticSeconds New optimistic timeout period\n     */\n    function _setOptimisticTimeout(uint256 _optimisticSeconds) internal {\n        // This allows us to initialize the value to be very low in test envs,\n        // but does not allow governance action to lower a production env below\n        // the safe value\n        uint256 _current = optimisticSeconds;\n        if (_current != 0 && _current > 1500)\n            require(_optimisticSeconds >= 1500, \"optimistic timeout too low\");\n        // ensure the optimistic timeout is less than 1 year\n        // (prevents overflow when adding block.timestamp)\n        require(_optimisticSeconds < 31536000, \"optimistic timeout too high\");\n        // set the optimistic timeout\n        optimisticSeconds = _optimisticSeconds;\n        emit SetOptimisticTimeout(_optimisticSeconds);\n    }\n\n    /// @notice Hook for potential future use\n    // solhint-disable-next-line no-empty-blocks\n    function _beforeUpdate() internal {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/nomad/core/interfaces/IMessageRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\ninterface IMessageRecipient {\n    function handle(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes32 _sender,\n        bytes memory _message\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/nomad/core/governance/GovernanceRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\n// ============ Internal Imports ============\nimport {Home} from \"../Home.sol\";\nimport {Version0} from \"../Version0.sol\";\nimport {XAppConnectionManager, TypeCasts} from \"../XAppConnectionManager.sol\";\nimport {IMessageRecipient} from \"../interfaces/IMessageRecipient.sol\";\nimport {GovernanceMessage} from \"./GovernanceMessage.sol\";\n// ============ External Imports ============\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {TypedMemView} from \"../../../summa/TypedMemView.sol\";\n\ncontract GovernanceRouter is Version0, Initializable, IMessageRecipient {\n    // ============ Libraries ============\n\n    using SafeMath for uint256;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using GovernanceMessage for bytes29;\n\n    // ============== Enums ==============\n\n    // The status of a batch of governance calls\n    enum BatchStatus {\n        Unknown, // 0\n        Pending, // 1\n        Complete // 2\n    }\n\n    // ============ Immutables ============\n\n    uint32 public immutable localDomain;\n    // number of seconds before recovery can be activated\n    uint256 public immutable recoveryTimelock;\n\n    // ============ Public Storage ============\n\n    // timestamp when recovery timelock expires; 0 if timelock has not been initiated\n    uint256 public recoveryActiveAt;\n    // the address of the recovery manager multisig\n    address public recoveryManager;\n    // the local entity empowered to call governance functions, set to 0x0 on non-Governor chains\n    address public governor;\n    // domain of Governor chain -- for accepting incoming messages from Governor\n    uint32 public governorDomain;\n    // xAppConnectionManager contract which stores Replica addresses\n    XAppConnectionManager public xAppConnectionManager;\n    // domain -> remote GovernanceRouter contract address\n    mapping(uint32 => bytes32) public routers;\n    // array of all domains with registered GovernanceRouter\n    uint32[] public domains;\n    // call hash -> call status\n    mapping(bytes32 => BatchStatus) public inboundCallBatches;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[42] private __GAP;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted a remote GovernanceRouter address is added, removed, or changed\n     * @param domain the domain of the remote Router\n     * @param previousRouter the previously registered router; 0 if router is being added\n     * @param newRouter the new registered router; 0 if router is being removed\n     */\n    event SetRouter(\n        uint32 indexed domain,\n        bytes32 previousRouter,\n        bytes32 newRouter\n    );\n\n    /**\n     * @notice Emitted when the Governor role is transferred\n     * @param previousGovernorDomain the domain of the previous Governor\n     * @param newGovernorDomain the domain of the new Governor\n     * @param previousGovernor the address of the previous Governor; 0 if the governor was remote\n     * @param newGovernor the address of the new Governor; 0 if the governor is remote\n     */\n    event TransferGovernor(\n        uint32 previousGovernorDomain,\n        uint32 newGovernorDomain,\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Emitted when the RecoveryManager role is transferred\n     * @param previousRecoveryManager the address of the previous RecoveryManager\n     * @param newRecoveryManager the address of the new RecoveryManager\n     */\n    event TransferRecoveryManager(\n        address indexed previousRecoveryManager,\n        address indexed newRecoveryManager\n    );\n\n    /**\n     * @notice Emitted when recovery state is initiated by the RecoveryManager\n     * @param recoveryManager the address of the current RecoveryManager who\n     * initiated the transition\n     * @param recoveryActiveAt the block at which recovery state will be active\n     */\n    event InitiateRecovery(\n        address indexed recoveryManager,\n        uint256 recoveryActiveAt\n    );\n\n    /**\n     * @notice Emitted when recovery state is exited by the RecoveryManager\n     * @param recoveryManager the address of the current RecoveryManager who\n     * initiated the transition\n     */\n    event ExitRecovery(address recoveryManager);\n\n    /**\n     * @notice Emitted when a batch of governance instructions from the\n     * governing remote router is received and ready for execution\n     * @param batchHash A hash committing to the batch of calls to be executed\n     */\n    event BatchReceived(bytes32 indexed batchHash);\n\n    /**\n     * @notice Emitted when a batch of governance instructions from the\n     * governing remote router is executed\n     * @param batchHash A hash committing to the batch of calls to be executed\n     */\n    event BatchExecuted(bytes32 indexed batchHash);\n\n    modifier typeAssert(bytes29 _view, GovernanceMessage.Types _type) {\n        _view.assertType(uint40(_type));\n        _;\n    }\n\n    // ============ Modifiers ============\n\n    modifier onlyReplica() {\n        require(xAppConnectionManager.isReplica(msg.sender), \"!replica\");\n        _;\n    }\n\n    modifier onlyGovernorRouter(uint32 _domain, bytes32 _address) {\n        require(_isGovernorRouter(_domain, _address), \"!governorRouter\");\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            msg.sender == governor || msg.sender == address(this),\n            \"! called by governor\"\n        );\n        _;\n    }\n\n    modifier onlyRecoveryManager() {\n        require(msg.sender == recoveryManager, \"! called by recovery manager\");\n        _;\n    }\n\n    modifier onlyNotInRecovery() {\n        require(!inRecovery(), \"in recovery\");\n        _;\n    }\n\n    modifier onlyGovernorOrRecoveryManager() {\n        if (!inRecovery()) {\n            require(\n                msg.sender == governor || msg.sender == address(this),\n                \"! called by governor\"\n            );\n        } else {\n            require(\n                msg.sender == recoveryManager || msg.sender == address(this),\n                \"! called by recovery manager\"\n            );\n        }\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(uint32 _localDomain, uint256 _recoveryTimelock) {\n        localDomain = _localDomain;\n        recoveryTimelock = _recoveryTimelock;\n    }\n\n    // ============ Initializer ============\n\n    function initialize(\n        address _xAppConnectionManager,\n        address _recoveryManager\n    ) public initializer {\n        // initialize governor\n        address _governorAddr = msg.sender;\n        bool _isLocalGovernor = true;\n        _transferGovernor(localDomain, _governorAddr, _isLocalGovernor);\n        // initialize recovery manager\n        recoveryManager = _recoveryManager;\n        // initialize XAppConnectionManager\n        setXAppConnectionManager(_xAppConnectionManager);\n        require(\n            xAppConnectionManager.localDomain() == localDomain,\n            \"XAppConnectionManager bad domain\"\n        );\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Handle Nomad messages\n     * For all non-Governor chains to handle messages\n     * sent from the Governor chain via Nomad.\n     * Governor chain should never receive messages,\n     * because non-Governor chains are not able to send them\n     * @param _origin The domain (of the Governor Router)\n     * @param _sender The message sender (must be the Governor Router)\n     * @param _message The message\n     */\n    function handle(\n        uint32 _origin,\n        uint32, // _nonce (unused)\n        bytes32 _sender,\n        bytes memory _message\n    ) external override onlyReplica onlyGovernorRouter(_origin, _sender) {\n        bytes29 _msg = _message.ref(0);\n        bytes29 _view = _msg.tryAsBatch();\n        if (_view.notNull()) {\n            _handleBatch(_view);\n            return;\n        }\n        _view = _msg.tryAsTransferGovernor();\n        if (_view.notNull()) {\n            _handleTransferGovernor(_view);\n            return;\n        }\n        require(false, \"!valid message type\");\n    }\n\n    /**\n     * @notice Dispatch a set of local and remote calls\n     * Local calls are executed immediately.\n     * Remote calls are dispatched to the remote domain for processing and\n     * execution.\n     * @dev The contents of the _domains array at the same index\n     * will determine the destination of messages in that _remoteCalls array.\n     * As such, all messages in an array MUST have the same destination.\n     * Missing destinations or too many will result in reverts.\n     * @param _localCalls An array of local calls\n     * @param _remoteCalls An array of arrays of remote calls\n     */\n    function executeGovernanceActions(\n        GovernanceMessage.Call[] calldata _localCalls,\n        uint32[] calldata _domains,\n        GovernanceMessage.Call[][] calldata _remoteCalls\n    ) external onlyGovernorOrRecoveryManager {\n        require(\n            _domains.length == _remoteCalls.length,\n            \"!domains length matches calls length\"\n        );\n        // remote calls are disallowed while in recovery\n        require(\n            _remoteCalls.length == 0 || !inRecovery(),\n            \"!remote calls in recovery mode\"\n        );\n        // _localCall loop\n        for (uint256 i = 0; i < _localCalls.length; i++) {\n            _callLocal(_localCalls[i]);\n        }\n        // remote calls loop\n        for (uint256 i = 0; i < _remoteCalls.length; i++) {\n            uint32 destination = _domains[i];\n            _callRemote(destination, _remoteCalls[i]);\n        }\n    }\n\n    /**\n     * @notice Dispatch calls on a remote chain via the remote GovernanceRouter\n     * @param _destination The domain of the remote chain\n     * @param _calls The calls\n     */\n    function _callRemote(\n        uint32 _destination,\n        GovernanceMessage.Call[] calldata _calls\n    ) internal onlyGovernor onlyNotInRecovery {\n        // ensure that destination chain has enrolled router\n        bytes32 _router = _mustHaveRouter(_destination);\n        // format batch message\n        bytes memory _msg = GovernanceMessage.formatBatch(_calls);\n        // dispatch call message using Nomad\n        Home(xAppConnectionManager.home()).dispatch(\n            _destination,\n            _router,\n            _msg\n        );\n    }\n\n    /**\n     * @notice Transfer governorship\n     * @param _newDomain The domain of the new governor\n     * @param _newGovernor The address of the new governor\n     */\n    function transferGovernor(uint32 _newDomain, address _newGovernor)\n        external\n        onlyGovernor\n        onlyNotInRecovery\n    {\n        bool _isLocalGovernor = _isLocalDomain(_newDomain);\n        // transfer the governor locally\n        _transferGovernor(_newDomain, _newGovernor, _isLocalGovernor);\n        // if the governor domain is local, we only need to change the governor address locally\n        // no need to message remote routers; they should already have the same domain set and governor = bytes32(0)\n        if (_isLocalGovernor) {\n            return;\n        }\n        // format transfer governor message\n        bytes memory _transferGovernorMessage = GovernanceMessage\n            .formatTransferGovernor(\n                _newDomain,\n                TypeCasts.addressToBytes32(_newGovernor)\n            );\n        // send transfer governor message to all remote routers\n        // note: this assumes that the Router is on the global GovernorDomain;\n        // this causes a process error when relinquishing governorship\n        // on a newly deployed domain which is not the GovernorDomain\n        _sendToAllRemoteRouters(_transferGovernorMessage);\n    }\n\n    /**\n     * @notice Transfer recovery manager role\n     * @dev callable by the recoveryManager at any time to transfer the role\n     * @param _newRecoveryManager The address of the new recovery manager\n     */\n    function transferRecoveryManager(address _newRecoveryManager)\n        external\n        onlyRecoveryManager\n    {\n        emit TransferRecoveryManager(recoveryManager, _newRecoveryManager);\n        recoveryManager = _newRecoveryManager;\n    }\n\n    /**\n     * @notice Set the router address for a given domain and\n     * dispatch the change to all remote routers\n     * @param _domain The domain\n     * @param _router The address of the new router\n     */\n    function setRouterGlobal(uint32 _domain, bytes32 _router)\n        external\n        onlyGovernor\n        onlyNotInRecovery\n    {\n        _setRouterGlobal(_domain, _router);\n    }\n\n    function _setRouterGlobal(uint32 _domain, bytes32 _router) internal {\n        Home _home = Home(xAppConnectionManager.home());\n        // Set up the call for use in the loop.\n        // Because each domain's governance router may be different, we cannot\n        // serialize the `Call` once and then reuse it. We have to re-serialize\n        // the call, adjusting its `to` value on each step of the loop.\n        GovernanceMessage.Call[] memory _calls = new GovernanceMessage.Call[](\n            1\n        );\n        _calls[0].data = abi.encodeWithSignature(\n            \"setRouterLocal(uint32,bytes32)\",\n            _domain,\n            _router\n        );\n        for (uint256 i = 0; i < domains.length; i++) {\n            uint32 _destination = domains[i];\n            if (_destination != uint32(0)) {\n                // set to, and dispatch\n                bytes32 _recipient = routers[_destination];\n                _calls[0].to = _recipient;\n                bytes memory _msg = GovernanceMessage.formatBatch(_calls);\n                _home.dispatch(_destination, _recipient, _msg);\n            }\n        }\n        // set the router locally\n        _setRouter(_domain, _router);\n    }\n\n    /**\n     * @notice Set the router address *locally only*\n     * @dev For use in deploy to setup the router mapping locally\n     * @param _domain The domain\n     * @param _router The new router\n     */\n    function setRouterLocal(uint32 _domain, bytes32 _router)\n        external\n        onlyGovernorOrRecoveryManager\n    {\n        // set the router locally\n        _setRouter(_domain, _router);\n    }\n\n    /**\n     * @notice Set the address of the XAppConnectionManager\n     * @dev Domain/address validation helper\n     * @param _xAppConnectionManager The address of the new xAppConnectionManager\n     */\n    function setXAppConnectionManager(address _xAppConnectionManager)\n        public\n        onlyGovernorOrRecoveryManager\n    {\n        xAppConnectionManager = XAppConnectionManager(_xAppConnectionManager);\n    }\n\n    /**\n     * @notice Initiate the recovery timelock\n     * @dev callable by the recovery manager\n     */\n    function initiateRecoveryTimelock()\n        external\n        onlyNotInRecovery\n        onlyRecoveryManager\n    {\n        require(recoveryActiveAt == 0, \"recovery already initiated\");\n        // set the time that recovery will be active\n        recoveryActiveAt = block.timestamp.add(recoveryTimelock);\n        emit InitiateRecovery(recoveryManager, recoveryActiveAt);\n    }\n\n    /**\n     * @notice Exit recovery mode\n     * @dev callable by the recovery manager to end recovery mode\n     */\n    function exitRecovery() external onlyRecoveryManager {\n        require(recoveryActiveAt != 0, \"recovery not initiated\");\n        delete recoveryActiveAt;\n        emit ExitRecovery(recoveryManager);\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Check if the contract is in recovery mode currently\n     * @return TRUE iff the contract is actively in recovery mode currently\n     */\n    function inRecovery() public view returns (bool) {\n        uint256 _recoveryActiveAt = recoveryActiveAt;\n        bool _recoveryInitiated = _recoveryActiveAt != 0;\n        bool _recoveryActive = _recoveryActiveAt <= block.timestamp;\n        return _recoveryInitiated && _recoveryActive;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Handle message dispatching calls locally\n     * @dev We considered requiring the batch was not previously known.\n     *      However, this would prevent us from ever processing identical\n     *      batches, which seems desirable in some cases.\n     *      As a result, we simply set it to pending.\n     * @param _msg The message\n     */\n    function _handleBatch(bytes29 _msg)\n        internal\n        typeAssert(_msg, GovernanceMessage.Types.Batch)\n    {\n        bytes32 _batchHash = _msg.batchHash();\n        // prevent accidental SSTORE and extra event if already pending\n        if (inboundCallBatches[_batchHash] == BatchStatus.Pending) return;\n        inboundCallBatches[_batchHash] = BatchStatus.Pending;\n        emit BatchReceived(_batchHash);\n    }\n\n    /**\n     * @notice execute a pending batch of messages\n     */\n    function executeCallBatch(GovernanceMessage.Call[] calldata _calls)\n        external\n    {\n        bytes32 _batchHash = GovernanceMessage.getBatchHash(_calls);\n        require(\n            inboundCallBatches[_batchHash] == BatchStatus.Pending,\n            \"!batch pending\"\n        );\n        inboundCallBatches[_batchHash] = BatchStatus.Complete;\n        for (uint256 i = 0; i < _calls.length; i++) {\n            _callLocal(_calls[i]);\n        }\n        emit BatchExecuted(_batchHash);\n    }\n\n    /**\n     * @notice Handle message transferring governorship to a new Governor\n     * @param _msg The message\n     */\n    function _handleTransferGovernor(bytes29 _msg)\n        internal\n        typeAssert(_msg, GovernanceMessage.Types.TransferGovernor)\n    {\n        uint32 _newDomain = _msg.domain();\n        address _newGovernor = TypeCasts.bytes32ToAddress(_msg.governor());\n        bool _isLocalGovernor = _isLocalDomain(_newDomain);\n        _transferGovernor(_newDomain, _newGovernor, _isLocalGovernor);\n    }\n\n    /**\n     * @notice Dispatch message to all remote routers\n     * @param _msg The message\n     */\n    function _sendToAllRemoteRouters(bytes memory _msg) internal {\n        Home _home = Home(xAppConnectionManager.home());\n\n        for (uint256 i = 0; i < domains.length; i++) {\n            if (domains[i] != uint32(0)) {\n                _home.dispatch(domains[i], routers[domains[i]], _msg);\n            }\n        }\n    }\n\n    /**\n     * @notice Dispatch call locally\n     * @param _call The call\n     * @return _ret\n     */\n    function _callLocal(GovernanceMessage.Call memory _call)\n        internal\n        returns (bytes memory _ret)\n    {\n        address _toContract = TypeCasts.bytes32ToAddress(_call.to);\n        // attempt to dispatch using low-level call\n        bool _success;\n        (_success, _ret) = _toContract.call(_call.data);\n        // revert if the call failed\n        require(_success, \"call failed\");\n    }\n\n    /**\n     * @notice Transfer governorship within this contract's state\n     * @param _newDomain The domain of the new governor\n     * @param _newGovernor The address of the new governor\n     * @param _isLocalGovernor True if the newDomain is the localDomain\n     */\n    function _transferGovernor(\n        uint32 _newDomain,\n        address _newGovernor,\n        bool _isLocalGovernor\n    ) internal {\n        // require that the new governor is not the zero address\n        require(_newGovernor != address(0), \"cannot renounce governor\");\n        // require that the governor domain has a valid router\n        if (!_isLocalGovernor) {\n            _mustHaveRouter(_newDomain);\n        }\n        // Governor is 0x0 unless the governor is local\n        address _newGov = _isLocalGovernor ? _newGovernor : address(0);\n        // emit event before updating state variables\n        emit TransferGovernor(governorDomain, _newDomain, governor, _newGov);\n        // update state\n        governorDomain = _newDomain;\n        governor = _newGov;\n    }\n\n    /**\n     * @notice Set the router for a given domain\n     * @param _domain The domain\n     * @param _newRouter The new router\n     */\n    function _setRouter(uint32 _domain, bytes32 _newRouter) internal {\n        // ignore local domain in router mapping\n        require(!_isLocalDomain(_domain), \"can't set local router\");\n        // store previous router in memory\n        bytes32 _previousRouter = routers[_domain];\n        // if router is being removed,\n        if (_newRouter == bytes32(0)) {\n            // remove domain from array\n            _removeDomain(_domain);\n            // remove router from mapping\n            delete routers[_domain];\n        } else {\n            // if router was not previously added,\n            if (_previousRouter == bytes32(0)) {\n                // add domain to array\n                _addDomain(_domain);\n            }\n            // set router in mapping (add or change)\n            routers[_domain] = _newRouter;\n        }\n        // emit event\n        emit SetRouter(_domain, _previousRouter, _newRouter);\n    }\n\n    /**\n     * @notice Add a domain that has a router\n     * @param _domain The domain\n     */\n    function _addDomain(uint32 _domain) internal {\n        domains.push(_domain);\n    }\n\n    /**\n     * @notice Remove a domain from array\n     * @param _domain The domain\n     */\n    function _removeDomain(uint32 _domain) internal {\n        // find the index of the domain to remove & delete it from domains[]\n        for (uint256 i = 0; i < domains.length; i++) {\n            if (domains[i] == _domain) {\n                delete domains[i];\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Determine if a given domain and address is the Governor Router\n     * @param _domain The domain\n     * @param _address The address of the domain's router\n     * @return _ret True if the given domain/address is the\n     * Governor Router.\n     */\n    function _isGovernorRouter(uint32 _domain, bytes32 _address)\n        internal\n        view\n        returns (bool)\n    {\n        return _domain == governorDomain && _address == routers[_domain];\n    }\n\n    /**\n     * @notice Determine if a given domain is the local domain\n     * @param _domain The domain\n     * @return _ret - True if the given domain is the local domain\n     */\n    function _isLocalDomain(uint32 _domain) internal view returns (bool) {\n        return _domain == localDomain;\n    }\n\n    /**\n     * @notice Require that a domain has a router and returns the router\n     * @param _domain The domain\n     * @return _router - The domain's router\n     */\n    function _mustHaveRouter(uint32 _domain)\n        internal\n        view\n        returns (bytes32 _router)\n    {\n        _router = routers[_domain];\n        require(_router != bytes32(0), \"!router\");\n    }\n}\n"
    },
    "contracts/nomad/core/governance/GovernanceMessage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\n// ============ External Imports ============\nimport {TypedMemView} from \"../../../summa/TypedMemView.sol\";\n\nlibrary GovernanceMessage {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Batch message characteristics\n    // * 1 item - the type\n    uint256 private constant BATCH_PREFIX_ITEMS = 1;\n    // * type is 1 byte long\n    uint256 private constant BATCH_PREFIX_LEN = 1;\n    // * Length of a Batch message\n    // * type + batch hash\n    uint256 private constant BATCH_MESSAGE_LEN = 1 + 32;\n\n    // Serialized Call[] characteristics\n    // * 1 item - the type\n    uint256 private constant CALLS_PREFIX_ITEMS = 1;\n    // * type is 1 byte long\n    uint256 private constant CALLS_PREFIX_LEN = 1;\n\n    // Serialized Call characteristics\n    // * Location of the data blob in a serialized call\n    // * address + length\n    uint256 private constant CALL_DATA_OFFSET = 32 + 4;\n\n    // Transfer Governance message characteristics\n    // * Length of a Transfer Governance message\n    // * type + domain + address\n    uint256 private constant TRANSFER_GOV_MESSAGE_LEN = 1 + 4 + 32;\n\n    struct Call {\n        bytes32 to;\n        bytes data;\n    }\n\n    enum Types {\n        Invalid, // 0\n        Batch, // 1 - A Batch message\n        TransferGovernor // 2 - A TransferGovernor message\n    }\n\n    // Read the type of a message\n    function messageType(bytes29 _view) internal pure returns (Types) {\n        return Types(uint8(_view.typeOf()));\n    }\n\n    // Read the message identifer (first byte) of a message\n    function identifier(bytes29 _view) internal pure returns (uint8) {\n        return uint8(_view.indexUint(0, 1));\n    }\n\n    /*\n     *   Message Type: BATCH\n     *   struct Call {\n     *       identifier,     // message ID -- 1 byte\n     *       batchHash       // Hash of serialized calls (see below) -- 32 bytes\n     *   }\n     *\n     *   struct Call {\n     *       to,         // address to call -- 32 bytes\n     *       dataLen,    // call data length -- 4 bytes,\n     *       data        // call data -- 0+ bytes (variable)\n     *   }\n     *\n     *   struct Calls\n     *       numCalls,   // number of calls -- 1 byte\n     *       calls[]     // serialized Call -- 0+ bytes\n     *   }\n     */\n\n    // create a Batch message from a list of calls\n    function formatBatch(Call[] memory _calls)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return abi.encodePacked(Types.Batch, getBatchHash(_calls));\n    }\n\n    // serialize a call to memory and return a reference\n    function serializeCall(Call memory _call) internal pure returns (bytes29) {\n        return\n            abi\n                .encodePacked(_call.to, uint32(_call.data.length), _call.data)\n                .ref(0);\n    }\n\n    function getBatchHash(Call[] memory _calls)\n        internal\n        view\n        returns (bytes32)\n    {\n        // length prefix + 1 entry for each\n        bytes29[] memory _encodedCalls = new bytes29[](\n            _calls.length + CALLS_PREFIX_ITEMS\n        );\n        _encodedCalls[0] = abi.encodePacked(uint8(_calls.length)).ref(0);\n        for (uint256 i = 0; i < _calls.length; i++) {\n            _encodedCalls[i + CALLS_PREFIX_ITEMS] = serializeCall(_calls[i]);\n        }\n        return keccak256(TypedMemView.join(_encodedCalls));\n    }\n\n    function isValidBatch(bytes29 _view) internal pure returns (bool) {\n        return\n            identifier(_view) == uint8(Types.Batch) &&\n            _view.len() == BATCH_MESSAGE_LEN;\n    }\n\n    function isBatch(bytes29 _view) internal pure returns (bool) {\n        return isValidBatch(_view) && messageType(_view) == Types.Batch;\n    }\n\n    function tryAsBatch(bytes29 _view) internal pure returns (bytes29) {\n        if (isValidBatch(_view)) {\n            return _view.castTo(uint40(Types.Batch));\n        }\n        return TypedMemView.nullView();\n    }\n\n    function mustBeBatch(bytes29 _view) internal pure returns (bytes29) {\n        return tryAsBatch(_view).assertValid();\n    }\n\n    // Types.Batch\n    function batchHash(bytes29 _view) internal pure returns (bytes32) {\n        return _view.index(BATCH_PREFIX_LEN, 32);\n    }\n\n    /*\n     *   Message Type: TRANSFER GOVERNOR\n     *   struct TransferGovernor {\n     *       identifier, // message ID -- 1 byte\n     *       domain,     // domain of new governor -- 4 bytes\n     *       addr        // address of new governor -- 32 bytes\n     *   }\n     */\n\n    function formatTransferGovernor(uint32 _domain, bytes32 _governor)\n        internal\n        view\n        returns (bytes memory _msg)\n    {\n        _msg = TypedMemView.clone(\n            mustBeTransferGovernor(\n                abi\n                    .encodePacked(Types.TransferGovernor, _domain, _governor)\n                    .ref(0)\n            )\n        );\n    }\n\n    function isValidTransferGovernor(bytes29 _view)\n        internal\n        pure\n        returns (bool)\n    {\n        return\n            identifier(_view) == uint8(Types.TransferGovernor) &&\n            _view.len() == TRANSFER_GOV_MESSAGE_LEN;\n    }\n\n    function isTransferGovernor(bytes29 _view) internal pure returns (bool) {\n        return\n            isValidTransferGovernor(_view) &&\n            messageType(_view) == Types.TransferGovernor;\n    }\n\n    function tryAsTransferGovernor(bytes29 _view)\n        internal\n        pure\n        returns (bytes29)\n    {\n        if (isValidTransferGovernor(_view)) {\n            return _view.castTo(uint40(Types.TransferGovernor));\n        }\n        return TypedMemView.nullView();\n    }\n\n    function mustBeTransferGovernor(bytes29 _view)\n        internal\n        pure\n        returns (bytes29)\n    {\n        return tryAsTransferGovernor(_view).assertValid();\n    }\n\n    // Types.TransferGovernor\n    function domain(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(1, 4));\n    }\n\n    // Types.TransferGovernor\n    function governor(bytes29 _view) internal pure returns (bytes32) {\n        return _view.index(5, 32);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/nomad/core/upgrade/UpgradeBeaconController.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {UpgradeBeacon} from \"./UpgradeBeacon.sol\";\n// ============ External Imports ============\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeaconController\n * @notice Set as the controller of UpgradeBeacon contract(s),\n * capable of changing their stored implementation address.\n * @dev This implementation is a minimal version inspired by 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/upgradeability/DharmaUpgradeBeaconController.sol\n */\ncontract UpgradeBeaconController is Ownable {\n    // ============ Events ============\n\n    event BeaconUpgraded(address indexed beacon, address implementation);\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Modify the implementation stored in the UpgradeBeacon,\n     * which will upgrade the implementation used by all\n     * Proxy contracts using that UpgradeBeacon\n     * @param _beacon Address of the UpgradeBeacon which will be updated\n     * @param _implementation Address of the Implementation contract to upgrade the Beacon to\n     */\n    function upgrade(address _beacon, address _implementation)\n        external\n        onlyOwner\n    {\n        // Require that the beacon is a contract\n        require(Address.isContract(_beacon), \"beacon !contract\");\n        // Call into beacon and supply address of new implementation to update it.\n        (bool _success, ) = _beacon.call(abi.encode(_implementation));\n        // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n        if (!_success) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n        emit BeaconUpgraded(_beacon, _implementation);\n    }\n}\n"
    },
    "contracts/nomad/core/upgrade/UpgradeBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeacon\n * @notice Stores the address of an implementation contract\n * and allows a controller to upgrade the implementation address\n * @dev This implementation combines the gas savings of having no function selectors\n * found in 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\n * With the added niceties of a safety check that each implementation is a contract\n * and an Upgrade event emitted each time the implementation is changed\n * found in OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol\n */\ncontract UpgradeBeacon {\n    // ============ Immutables ============\n\n    // The controller is capable of modifying the implementation address\n    address private immutable controller;\n\n    // ============ Private Storage Variables ============\n\n    // The implementation address is held in storage slot zero.\n    address private implementation;\n\n    // ============ Events ============\n\n    // Upgrade event is emitted each time the implementation address is set\n    // (including deployment)\n    event Upgrade(address indexed implementation);\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Validate the initial implementation and store it.\n     * Store the controller immutably.\n     * @param _initialImplementation Address of the initial implementation contract\n     * @param _controller Address of the controller who can upgrade the implementation\n     */\n    constructor(address _initialImplementation, address _controller) {\n        _setImplementation(_initialImplementation);\n        controller = _controller;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice For all callers except the controller, return the current implementation address.\n     * If called by the Controller, update the implementation address\n     * to the address passed in the calldata.\n     * Note: this requires inline assembly because Solidity fallback functions\n     * do not natively take arguments or return values.\n     */\n    fallback() external payable {\n        if (msg.sender != controller) {\n            // if not called by the controller,\n            // load implementation address from storage slot zero\n            // and return it.\n            assembly {\n                mstore(0, sload(0))\n                return(0, 32)\n            }\n        } else {\n            // if called by the controller,\n            // load new implementation address from the first word of the calldata\n            address _newImplementation;\n            assembly {\n                _newImplementation := calldataload(0)\n            }\n            // set the new implementation\n            _setImplementation(_newImplementation);\n        }\n    }\n\n    // ============ Private Functions ============\n\n    /**\n     * @notice Perform checks on the new implementation address\n     * then upgrade the stored implementation.\n     * @param _newImplementation Address of the new implementation contract which will replace the old one\n     */\n    function _setImplementation(address _newImplementation) private {\n        // Require that the new implementation is different from the current one\n        require(implementation != _newImplementation, \"!upgrade\");\n        // Require that the new implementation is a contract\n        require(\n            Address.isContract(_newImplementation),\n            \"implementation !contract\"\n        );\n        // set the new implementation\n        implementation = _newImplementation;\n        emit Upgrade(_newImplementation);\n    }\n}\n"
    },
    "contracts/nomad/core/UpdaterManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.15;\n\n// ============ Internal Imports ============\nimport {IUpdaterManager} from \"./interfaces/IUpdaterManager.sol\";\nimport {Home} from \"./Home.sol\";\n// ============ External Imports ============\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpdaterManager\n * @author Illusory Systems Inc.\n * @notice MVP / centralized version of contract\n * that will manage Updater bonding, slashing,\n * selection and rotation\n */\ncontract UpdaterManager is IUpdaterManager, Ownable {\n    // ============ Internal Storage ============\n\n    // address of home contract\n    address internal home;\n\n    // ============ Private Storage ============\n\n    // address of the current updater\n    address private _updater;\n\n    // ============ Events ============\n\n    /**\n     * @notice Emitted when a new home is set\n     * @param home The address of the new home contract\n     */\n    event NewHome(address home);\n\n    /**\n     * @notice Emitted when slashUpdater is called\n     */\n    event FakeSlashed(address reporter);\n\n    // ============ Modifiers ============\n\n    /**\n     * @notice Require that the function is called\n     * by the Home contract\n     */\n    modifier onlyHome() {\n        require(msg.sender == home, \"!home\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _updaterAddress) payable Ownable() {\n        _updater = _updaterAddress;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Set the address of the a new home contract\n     * @dev only callable by trusted owner\n     * @param _home The address of the new home contract\n     */\n    function setHome(address _home) external onlyOwner {\n        require(Address.isContract(_home), \"!contract home\");\n        home = _home;\n\n        emit NewHome(_home);\n    }\n\n    /**\n     * @notice Set the address of a new updater\n     * @dev only callable by trusted owner\n     * @param _updaterAddress The address of the new updater\n     */\n    function setUpdater(address _updaterAddress) external onlyOwner {\n        _updater = _updaterAddress;\n        Home(home).setUpdater(_updaterAddress);\n    }\n\n    /**\n     * @notice Slashes the updater\n     * @dev Currently does nothing, functionality will be implemented later\n     * when updater bonding and rotation are also implemented\n     * @param _reporter The address of the entity that reported the updater fraud\n     */\n    function slashUpdater(address payable _reporter)\n        external\n        override\n        onlyHome\n    {\n        emit FakeSlashed(_reporter);\n    }\n\n    /**\n     * @notice Get address of current updater\n     * @return the updater address\n     */\n    function updater() external view override returns (address) {\n        return _updater;\n    }\n\n    /**\n     * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin Ownable implementation\n     * of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n}\n"
    },
    "contracts/mocks/SimpleToken.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `ERC20` functions.\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/examples/SimpleToken.sol\n */\ncontract SimpleToken is ERC20, ERC20Permit {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}